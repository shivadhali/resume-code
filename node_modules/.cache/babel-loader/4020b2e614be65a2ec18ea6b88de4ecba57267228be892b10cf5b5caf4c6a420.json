{"ast":null,"code":"import _objectSpread from \"/home/ubuntu/Documents/myLearning/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nclass ClientResponseError extends Error {\n  constructor(e) {\n    var _this$response, _this$originalError;\n    super(\"ClientResponseError\"), this.url = \"\", this.status = 0, this.response = {}, this.isAbort = !1, this.originalError = null, Object.setPrototypeOf(this, ClientResponseError.prototype), null !== e && \"object\" == typeof e && (this.url = \"string\" == typeof e.url ? e.url : \"\", this.status = \"number\" == typeof e.status ? e.status : 0, this.isAbort = !!e.isAbort, this.originalError = e.originalError, null !== e.response && \"object\" == typeof e.response ? this.response = e.response : null !== e.data && \"object\" == typeof e.data ? this.response = e.data : this.response = {}), this.originalError || e instanceof ClientResponseError || (this.originalError = e), \"undefined\" != typeof DOMException && e instanceof DOMException && (this.isAbort = !0), this.name = \"ClientResponseError \" + this.status, this.message = (_this$response = this.response) === null || _this$response === void 0 ? void 0 : _this$response.message, this.message || (this.isAbort ? this.message = \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\" : (_this$originalError = this.originalError) !== null && _this$originalError !== void 0 && (_this$originalError = _this$originalError.cause) !== null && _this$originalError !== void 0 && (_this$originalError = _this$originalError.message) !== null && _this$originalError !== void 0 && _this$originalError.includes(\"ECONNREFUSED ::1\") ? this.message = \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\" : this.message = \"Something went wrong.\"), this.cause = this.originalError;\n  }\n  get data() {\n    return this.response;\n  }\n  toJSON() {\n    return _objectSpread({}, this);\n  }\n}\nconst e = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nfunction cookieParse(e, t) {\n  const s = {};\n  if (\"string\" != typeof e) return s;\n  const i = Object.assign({}, t || {}).decode || defaultDecode;\n  let n = 0;\n  for (; n < e.length;) {\n    const t = e.indexOf(\"=\", n);\n    if (-1 === t) break;\n    let r = e.indexOf(\";\", n);\n    if (-1 === r) r = e.length;else if (r < t) {\n      n = e.lastIndexOf(\";\", t - 1) + 1;\n      continue;\n    }\n    const o = e.slice(n, t).trim();\n    if (void 0 === s[o]) {\n      let n = e.slice(t + 1, r).trim();\n      34 === n.charCodeAt(0) && (n = n.slice(1, -1));\n      try {\n        s[o] = i(n);\n      } catch (e) {\n        s[o] = n;\n      }\n    }\n    n = r + 1;\n  }\n  return s;\n}\nfunction cookieSerialize(t, s, i) {\n  const n = Object.assign({}, i || {}),\n    r = n.encode || defaultEncode;\n  if (!e.test(t)) throw new TypeError(\"argument name is invalid\");\n  const o = r(s);\n  if (o && !e.test(o)) throw new TypeError(\"argument val is invalid\");\n  let a = t + \"=\" + o;\n  if (null != n.maxAge) {\n    const e = n.maxAge - 0;\n    if (isNaN(e) || !isFinite(e)) throw new TypeError(\"option maxAge is invalid\");\n    a += \"; Max-Age=\" + Math.floor(e);\n  }\n  if (n.domain) {\n    if (!e.test(n.domain)) throw new TypeError(\"option domain is invalid\");\n    a += \"; Domain=\" + n.domain;\n  }\n  if (n.path) {\n    if (!e.test(n.path)) throw new TypeError(\"option path is invalid\");\n    a += \"; Path=\" + n.path;\n  }\n  if (n.expires) {\n    if (!function isDate(e) {\n      return \"[object Date]\" === Object.prototype.toString.call(e) || e instanceof Date;\n    }(n.expires) || isNaN(n.expires.valueOf())) throw new TypeError(\"option expires is invalid\");\n    a += \"; Expires=\" + n.expires.toUTCString();\n  }\n  if (n.httpOnly && (a += \"; HttpOnly\"), n.secure && (a += \"; Secure\"), n.priority) {\n    switch (\"string\" == typeof n.priority ? n.priority.toLowerCase() : n.priority) {\n      case \"low\":\n        a += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        a += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        a += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(\"option priority is invalid\");\n    }\n  }\n  if (n.sameSite) {\n    switch (\"string\" == typeof n.sameSite ? n.sameSite.toLowerCase() : n.sameSite) {\n      case !0:\n        a += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        a += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        a += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        a += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return a;\n}\nfunction defaultDecode(e) {\n  return -1 !== e.indexOf(\"%\") ? decodeURIComponent(e) : e;\n}\nfunction defaultEncode(e) {\n  return encodeURIComponent(e);\n}\nconst t = \"undefined\" != typeof navigator && \"ReactNative\" === navigator.product || \"undefined\" != typeof global && global.HermesInternal;\nlet s;\nfunction getTokenPayload(e) {\n  if (e) try {\n    const t = decodeURIComponent(s(e.split(\".\")[1]).split(\"\").map(function (e) {\n      return \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2);\n    }).join(\"\"));\n    return JSON.parse(t) || {};\n  } catch (e) {}\n  return {};\n}\nfunction isTokenExpired(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let s = getTokenPayload(e);\n  return !(Object.keys(s).length > 0 && (!s.exp || s.exp - t > Date.now() / 1e3));\n}\ns = \"function\" != typeof atob || t ? e => {\n  let t = String(e).replace(/=+$/, \"\");\n  if (t.length % 4 == 1) throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  for (var s, i, n = 0, r = 0, o = \"\"; i = t.charAt(r++); ~i && (s = n % 4 ? 64 * s + i : i, n++ % 4) ? o += String.fromCharCode(255 & s >> (-2 * n & 6)) : 0) i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(i);\n  return o;\n} : atob;\nconst i = \"pb_auth\";\nclass BaseAuthStore {\n  constructor() {\n    this.baseToken = \"\", this.baseModel = null, this._onChangeCallbacks = [];\n  }\n  get token() {\n    return this.baseToken;\n  }\n  get record() {\n    return this.baseModel;\n  }\n  get model() {\n    return this.baseModel;\n  }\n  get isValid() {\n    return !isTokenExpired(this.token);\n  }\n  get isSuperuser() {\n    var _this$record, _this$record2;\n    let e = getTokenPayload(this.token);\n    return \"auth\" == e.type && (\"_superusers\" == ((_this$record = this.record) === null || _this$record === void 0 ? void 0 : _this$record.collectionName) || !((_this$record2 = this.record) !== null && _this$record2 !== void 0 && _this$record2.collectionName) && \"pbc_3142635823\" == e.collectionId);\n  }\n  get isAdmin() {\n    return console.warn(\"Please replace pb.authStore.isAdmin with pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\"), this.isSuperuser;\n  }\n  get isAuthRecord() {\n    return console.warn(\"Please replace pb.authStore.isAuthRecord with !pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\"), \"auth\" == getTokenPayload(this.token).type && !this.isSuperuser;\n  }\n  save(e, t) {\n    this.baseToken = e || \"\", this.baseModel = t || null, this.triggerChange();\n  }\n  clear() {\n    this.baseToken = \"\", this.baseModel = null, this.triggerChange();\n  }\n  loadFromCookie(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : i;\n    const s = cookieParse(e || \"\")[t] || \"\";\n    let n = {};\n    try {\n      n = JSON.parse(s), (null === typeof n || \"object\" != typeof n || Array.isArray(n)) && (n = {});\n    } catch (e) {}\n    this.save(n.token || \"\", n.record || n.model || null);\n  }\n  exportToCookie(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : i;\n    const s = {\n        secure: !0,\n        sameSite: !0,\n        httpOnly: !0,\n        path: \"/\"\n      },\n      n = getTokenPayload(this.token);\n    s.expires = n !== null && n !== void 0 && n.exp ? new Date(1e3 * n.exp) : new Date(\"1970-01-01\"), e = Object.assign({}, s, e);\n    const r = {\n      token: this.token,\n      record: this.record ? JSON.parse(JSON.stringify(this.record)) : null\n    };\n    let o = cookieSerialize(t, JSON.stringify(r), e);\n    const a = \"undefined\" != typeof Blob ? new Blob([o]).size : o.length;\n    if (r.record && a > 4096) {\n      var _r$record, _r$record2;\n      r.record = {\n        id: (_r$record = r.record) === null || _r$record === void 0 ? void 0 : _r$record.id,\n        email: (_r$record2 = r.record) === null || _r$record2 === void 0 ? void 0 : _r$record2.email\n      };\n      const s = [\"collectionId\", \"collectionName\", \"verified\"];\n      for (const e in this.record) s.includes(e) && (r.record[e] = this.record[e]);\n      o = cookieSerialize(t, JSON.stringify(r), e);\n    }\n    return o;\n  }\n  onChange(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    return this._onChangeCallbacks.push(e), t && e(this.token, this.record), () => {\n      for (let t = this._onChangeCallbacks.length - 1; t >= 0; t--) if (this._onChangeCallbacks[t] == e) return delete this._onChangeCallbacks[t], void this._onChangeCallbacks.splice(t, 1);\n    };\n  }\n  triggerChange() {\n    for (const e of this._onChangeCallbacks) e && e(this.token, this.record);\n  }\n}\nclass LocalAuthStore extends BaseAuthStore {\n  constructor() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"pocketbase_auth\";\n    super(), this.storageFallback = {}, this.storageKey = e, this._bindStorageEvent();\n  }\n  get token() {\n    return (this._storageGet(this.storageKey) || {}).token || \"\";\n  }\n  get record() {\n    const e = this._storageGet(this.storageKey) || {};\n    return e.record || e.model || null;\n  }\n  get model() {\n    return this.record;\n  }\n  save(e, t) {\n    this._storageSet(this.storageKey, {\n      token: e,\n      record: t\n    }), super.save(e, t);\n  }\n  clear() {\n    this._storageRemove(this.storageKey), super.clear();\n  }\n  _storageGet(e) {\n    var _window;\n    if (\"undefined\" != typeof window && (_window = window) !== null && _window !== void 0 && _window.localStorage) {\n      const t = window.localStorage.getItem(e) || \"\";\n      try {\n        return JSON.parse(t);\n      } catch (e) {\n        return t;\n      }\n    }\n    return this.storageFallback[e];\n  }\n  _storageSet(e, t) {\n    var _window2;\n    if (\"undefined\" != typeof window && (_window2 = window) !== null && _window2 !== void 0 && _window2.localStorage) {\n      let s = t;\n      \"string\" != typeof t && (s = JSON.stringify(t)), window.localStorage.setItem(e, s);\n    } else this.storageFallback[e] = t;\n  }\n  _storageRemove(e) {\n    var _window3, _window$localStorage;\n    \"undefined\" != typeof window && (_window3 = window) !== null && _window3 !== void 0 && _window3.localStorage && (_window$localStorage = window.localStorage) !== null && _window$localStorage !== void 0 && _window$localStorage.removeItem(e), delete this.storageFallback[e];\n  }\n  _bindStorageEvent() {\n    var _window4;\n    \"undefined\" != typeof window && ((_window4 = window) === null || _window4 === void 0 ? void 0 : _window4.localStorage) && window.addEventListener && window.addEventListener(\"storage\", e => {\n      if (e.key != this.storageKey) return;\n      const t = this._storageGet(this.storageKey) || {};\n      super.save(t.token || \"\", t.record || t.model || null);\n    });\n  }\n}\nclass BaseService {\n  constructor(e) {\n    this.client = e;\n  }\n}\nclass SettingsService extends BaseService {\n  async getAll(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(\"/api/settings\", e);\n  }\n  async update(e, t) {\n    return t = Object.assign({\n      method: \"PATCH\",\n      body: e\n    }, t), this.client.send(\"/api/settings\", t);\n  }\n  async testS3() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"storage\";\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    return t = Object.assign({\n      method: \"POST\",\n      body: {\n        filesystem: e\n      }\n    }, t), this.client.send(\"/api/settings/test/s3\", t).then(() => !0);\n  }\n  async testEmail(e, t, s, i) {\n    return i = Object.assign({\n      method: \"POST\",\n      body: {\n        email: t,\n        template: s,\n        collection: e\n      }\n    }, i), this.client.send(\"/api/settings/test/email\", i).then(() => !0);\n  }\n  async generateAppleClientSecret(e, t, s, i, n, r) {\n    return r = Object.assign({\n      method: \"POST\",\n      body: {\n        clientId: e,\n        teamId: t,\n        keyId: s,\n        privateKey: i,\n        duration: n\n      }\n    }, r), this.client.send(\"/api/settings/apple/generate-client-secret\", r);\n  }\n}\nconst n = [\"requestKey\", \"$cancelKey\", \"$autoCancel\", \"fetch\", \"headers\", \"body\", \"query\", \"params\", \"cache\", \"credentials\", \"headers\", \"integrity\", \"keepalive\", \"method\", \"mode\", \"redirect\", \"referrer\", \"referrerPolicy\", \"signal\", \"window\"];\nfunction normalizeUnknownQueryParams(e) {\n  if (e) {\n    e.query = e.query || {};\n    for (let t in e) n.includes(t) || (e.query[t] = e[t], delete e[t]);\n  }\n}\nfunction serializeQueryParams(e) {\n  const t = [];\n  for (const s in e) {\n    const i = encodeURIComponent(s),\n      n = Array.isArray(e[s]) ? e[s] : [e[s]];\n    for (let e of n) e = prepareQueryParamValue(e), null !== e && t.push(i + \"=\" + e);\n  }\n  return t.join(\"&\");\n}\nfunction prepareQueryParamValue(e) {\n  return null == e ? null : e instanceof Date ? encodeURIComponent(e.toISOString().replace(\"T\", \" \")) : \"object\" == typeof e ? encodeURIComponent(JSON.stringify(e)) : encodeURIComponent(e);\n}\nclass RealtimeService extends BaseService {\n  constructor() {\n    super(...arguments), this.clientId = \"\", this.eventSource = null, this.subscriptions = {}, this.lastSentSubscriptions = [], this.maxConnectTimeout = 15e3, this.reconnectAttempts = 0, this.maxReconnectAttempts = 1 / 0, this.predefinedReconnectIntervals = [200, 300, 500, 1e3, 1200, 1500, 2e3], this.pendingConnects = [];\n  }\n  get isConnected() {\n    return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n  }\n  async subscribe(e, t, s) {\n    var _this$eventSource;\n    if (!e) throw new Error(\"topic must be set.\");\n    let i = e;\n    if (s) {\n      normalizeUnknownQueryParams(s = Object.assign({}, s));\n      const e = \"options=\" + encodeURIComponent(JSON.stringify({\n        query: s.query,\n        headers: s.headers\n      }));\n      i += (i.includes(\"?\") ? \"&\" : \"?\") + e;\n    }\n    const listener = function (e) {\n      const s = e;\n      let i;\n      try {\n        i = JSON.parse(s === null || s === void 0 ? void 0 : s.data);\n      } catch (_unused) {}\n      t(i || {});\n    };\n    return this.subscriptions[i] || (this.subscriptions[i] = []), this.subscriptions[i].push(listener), this.isConnected ? 1 === this.subscriptions[i].length ? await this.submitSubscriptions() : (_this$eventSource = this.eventSource) === null || _this$eventSource === void 0 ? void 0 : _this$eventSource.addEventListener(i, listener) : await this.connect(), async () => this.unsubscribeByTopicAndListener(e, listener);\n  }\n  async unsubscribe(e) {\n    let t = !1;\n    if (e) {\n      const s = this.getSubscriptionsByTopic(e);\n      for (let e in s) if (this.hasSubscriptionListeners(e)) {\n        for (let t of this.subscriptions[e]) {\n          var _this$eventSource2;\n          (_this$eventSource2 = this.eventSource) === null || _this$eventSource2 === void 0 || _this$eventSource2.removeEventListener(e, t);\n        }\n        delete this.subscriptions[e], t || (t = !0);\n      }\n    } else this.subscriptions = {};\n    this.hasSubscriptionListeners() ? t && (await this.submitSubscriptions()) : this.disconnect();\n  }\n  async unsubscribeByPrefix(e) {\n    let t = !1;\n    for (let s in this.subscriptions) if ((s + \"?\").startsWith(e)) {\n      t = !0;\n      for (let e of this.subscriptions[s]) {\n        var _this$eventSource3;\n        (_this$eventSource3 = this.eventSource) === null || _this$eventSource3 === void 0 || _this$eventSource3.removeEventListener(s, e);\n      }\n      delete this.subscriptions[s];\n    }\n    t && (this.hasSubscriptionListeners() ? await this.submitSubscriptions() : this.disconnect());\n  }\n  async unsubscribeByTopicAndListener(e, t) {\n    let s = !1;\n    const i = this.getSubscriptionsByTopic(e);\n    for (let e in i) {\n      if (!Array.isArray(this.subscriptions[e]) || !this.subscriptions[e].length) continue;\n      let i = !1;\n      for (let s = this.subscriptions[e].length - 1; s >= 0; s--) {\n        var _this$eventSource4;\n        this.subscriptions[e][s] === t && (i = !0, delete this.subscriptions[e][s], this.subscriptions[e].splice(s, 1), (_this$eventSource4 = this.eventSource) === null || _this$eventSource4 === void 0 ? void 0 : _this$eventSource4.removeEventListener(e, t));\n      }\n      i && (this.subscriptions[e].length || delete this.subscriptions[e], s || this.hasSubscriptionListeners(e) || (s = !0));\n    }\n    this.hasSubscriptionListeners() ? s && (await this.submitSubscriptions()) : this.disconnect();\n  }\n  hasSubscriptionListeners(e) {\n    var _this$subscriptions$e;\n    if (this.subscriptions = this.subscriptions || {}, e) return !!((_this$subscriptions$e = this.subscriptions[e]) !== null && _this$subscriptions$e !== void 0 && _this$subscriptions$e.length);\n    for (let e in this.subscriptions) {\n      var _this$subscriptions$e2;\n      if ((_this$subscriptions$e2 = this.subscriptions[e]) !== null && _this$subscriptions$e2 !== void 0 && _this$subscriptions$e2.length) return !0;\n    }\n    return !1;\n  }\n  async submitSubscriptions() {\n    if (this.clientId) return this.addAllSubscriptionListeners(), this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys(), this.client.send(\"/api/realtime\", {\n      method: \"POST\",\n      body: {\n        clientId: this.clientId,\n        subscriptions: this.lastSentSubscriptions\n      },\n      requestKey: this.getSubscriptionsCancelKey()\n    }).catch(e => {\n      if (!(e !== null && e !== void 0 && e.isAbort)) throw e;\n    });\n  }\n  getSubscriptionsCancelKey() {\n    return \"realtime_\" + this.clientId;\n  }\n  getSubscriptionsByTopic(e) {\n    const t = {};\n    e = e.includes(\"?\") ? e : e + \"?\";\n    for (let s in this.subscriptions) (s + \"?\").startsWith(e) && (t[s] = this.subscriptions[s]);\n    return t;\n  }\n  getNonEmptySubscriptionKeys() {\n    const e = [];\n    for (let t in this.subscriptions) this.subscriptions[t].length && e.push(t);\n    return e;\n  }\n  addAllSubscriptionListeners() {\n    if (this.eventSource) {\n      this.removeAllSubscriptionListeners();\n      for (let e in this.subscriptions) for (let t of this.subscriptions[e]) this.eventSource.addEventListener(e, t);\n    }\n  }\n  removeAllSubscriptionListeners() {\n    if (this.eventSource) for (let e in this.subscriptions) for (let t of this.subscriptions[e]) this.eventSource.removeEventListener(e, t);\n  }\n  async connect() {\n    if (!(this.reconnectAttempts > 0)) return new Promise((e, t) => {\n      this.pendingConnects.push({\n        resolve: e,\n        reject: t\n      }), this.pendingConnects.length > 1 || this.initConnect();\n    });\n  }\n  initConnect() {\n    this.disconnect(!0), clearTimeout(this.connectTimeoutId), this.connectTimeoutId = setTimeout(() => {\n      this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n    }, this.maxConnectTimeout), this.eventSource = new EventSource(this.client.buildURL(\"/api/realtime\")), this.eventSource.onerror = e => {\n      this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n    }, this.eventSource.addEventListener(\"PB_CONNECT\", e => {\n      const t = e;\n      this.clientId = t === null || t === void 0 ? void 0 : t.lastEventId, this.submitSubscriptions().then(async () => {\n        let e = 3;\n        for (; this.hasUnsentSubscriptions() && e > 0;) e--, await this.submitSubscriptions();\n      }).then(() => {\n        for (let e of this.pendingConnects) e.resolve();\n        this.pendingConnects = [], this.reconnectAttempts = 0, clearTimeout(this.reconnectTimeoutId), clearTimeout(this.connectTimeoutId);\n        const t = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n        for (let s in t) for (let i of t[s]) i(e);\n      }).catch(e => {\n        this.clientId = \"\", this.connectErrorHandler(e);\n      });\n    });\n  }\n  hasUnsentSubscriptions() {\n    const e = this.getNonEmptySubscriptionKeys();\n    if (e.length != this.lastSentSubscriptions.length) return !0;\n    for (const t of e) if (!this.lastSentSubscriptions.includes(t)) return !0;\n    return !1;\n  }\n  connectErrorHandler(e) {\n    if (clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), !this.clientId && !this.reconnectAttempts || this.reconnectAttempts > this.maxReconnectAttempts) {\n      for (let t of this.pendingConnects) t.reject(new ClientResponseError(e));\n      return this.pendingConnects = [], void this.disconnect();\n    }\n    this.disconnect(!0);\n    const t = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n    this.reconnectAttempts++, this.reconnectTimeoutId = setTimeout(() => {\n      this.initConnect();\n    }, t);\n  }\n  disconnect() {\n    var _this$eventSource5;\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    if (this.clientId && this.onDisconnect && this.onDisconnect(Object.keys(this.subscriptions)), clearTimeout(this.connectTimeoutId), clearTimeout(this.reconnectTimeoutId), this.removeAllSubscriptionListeners(), this.client.cancelRequest(this.getSubscriptionsCancelKey()), (_this$eventSource5 = this.eventSource) !== null && _this$eventSource5 !== void 0 && _this$eventSource5.close(), this.eventSource = null, this.clientId = \"\", !e) {\n      this.reconnectAttempts = 0;\n      for (let e of this.pendingConnects) e.resolve();\n      this.pendingConnects = [];\n    }\n  }\n}\nclass CrudService extends BaseService {\n  decode(e) {\n    return e;\n  }\n  async getFullList(e, t) {\n    if (\"number\" == typeof e) return this._getFullList(e, t);\n    let s = 500;\n    return (t = Object.assign({}, e, t)).batch && (s = t.batch, delete t.batch), this._getFullList(s, t);\n  }\n  async getList() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    return (s = Object.assign({\n      method: \"GET\"\n    }, s)).query = Object.assign({\n      page: e,\n      perPage: t\n    }, s.query), this.client.send(this.baseCrudPath, s).then(e => {\n      var _e$items;\n      return e.items = ((_e$items = e.items) === null || _e$items === void 0 ? void 0 : _e$items.map(e => this.decode(e))) || [], e;\n    });\n  }\n  async getFirstListItem(e, t) {\n    return (t = Object.assign({\n      requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + e\n    }, t)).query = Object.assign({\n      filter: e,\n      skipTotal: 1\n    }, t.query), this.getList(1, 1, t).then(e => {\n      var _e$items2;\n      if (!(e !== null && e !== void 0 && (_e$items2 = e.items) !== null && _e$items2 !== void 0 && _e$items2.length)) throw new ClientResponseError({\n        status: 404,\n        response: {\n          code: 404,\n          message: \"The requested resource wasn't found.\",\n          data: {}\n        }\n      });\n      return e.items[0];\n    });\n  }\n  async getOne(e, t) {\n    if (!e) throw new ClientResponseError({\n      url: this.client.buildURL(this.baseCrudPath + \"/\"),\n      status: 404,\n      response: {\n        code: 404,\n        message: \"Missing required record id.\",\n        data: {}\n      }\n    });\n    return t = Object.assign({\n      method: \"GET\"\n    }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), t).then(e => this.decode(e));\n  }\n  async create(e, t) {\n    return t = Object.assign({\n      method: \"POST\",\n      body: e\n    }, t), this.client.send(this.baseCrudPath, t).then(e => this.decode(e));\n  }\n  async update(e, t, s) {\n    return s = Object.assign({\n      method: \"PATCH\",\n      body: t\n    }, s), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), s).then(e => this.decode(e));\n  }\n  async delete(e, t) {\n    return t = Object.assign({\n      method: \"DELETE\"\n    }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e), t).then(() => !0);\n  }\n  _getFullList() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    (t = t || {}).query = Object.assign({\n      skipTotal: 1\n    }, t.query);\n    let s = [],\n      request = async i => this.getList(i, e || 500, t).then(e => {\n        const t = e.items;\n        return s = s.concat(t), t.length == e.perPage ? request(i + 1) : s;\n      });\n    return request(1);\n  }\n}\nfunction normalizeLegacyOptionsArgs(e, t, s, i) {\n  const n = void 0 !== i;\n  return n || void 0 !== s ? n ? (console.warn(e), t.body = Object.assign({}, t.body, s), t.query = Object.assign({}, t.query, i), t) : Object.assign(t, s) : t;\n}\nfunction resetAutoRefresh(e) {\n  var _e$_resetAutoRefresh;\n  (_e$_resetAutoRefresh = e._resetAutoRefresh) === null || _e$_resetAutoRefresh === void 0 || _e$_resetAutoRefresh.call(e);\n}\nclass RecordService extends CrudService {\n  constructor(e, t) {\n    super(e), this.collectionIdOrName = t;\n  }\n  get baseCrudPath() {\n    return this.baseCollectionPath + \"/records\";\n  }\n  get baseCollectionPath() {\n    return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n  }\n  get isSuperusers() {\n    return \"_superusers\" == this.collectionIdOrName || \"_pbc_2773867675\" == this.collectionIdOrName;\n  }\n  async subscribe(e, t, s) {\n    if (!e) throw new Error(\"Missing topic.\");\n    if (!t) throw new Error(\"Missing subscription callback.\");\n    return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + e, t, s);\n  }\n  async unsubscribe(e) {\n    return e ? this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + e) : this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n  }\n  async getFullList(e, t) {\n    if (\"number\" == typeof e) return super.getFullList(e, t);\n    const s = Object.assign({}, e, t);\n    return super.getFullList(s);\n  }\n  async getList() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    return super.getList(e, t, s);\n  }\n  async getFirstListItem(e, t) {\n    return super.getFirstListItem(e, t);\n  }\n  async getOne(e, t) {\n    return super.getOne(e, t);\n  }\n  async create(e, t) {\n    return super.create(e, t);\n  }\n  async update(e, t, s) {\n    return super.update(e, t, s).then(e => {\n      var _this$client$authStor, _this$client$authStor2, _this$client$authStor3;\n      if (((_this$client$authStor = this.client.authStore.record) === null || _this$client$authStor === void 0 ? void 0 : _this$client$authStor.id) === (e === null || e === void 0 ? void 0 : e.id) && (((_this$client$authStor2 = this.client.authStore.record) === null || _this$client$authStor2 === void 0 ? void 0 : _this$client$authStor2.collectionId) === this.collectionIdOrName || ((_this$client$authStor3 = this.client.authStore.record) === null || _this$client$authStor3 === void 0 ? void 0 : _this$client$authStor3.collectionName) === this.collectionIdOrName)) {\n        let t = Object.assign({}, this.client.authStore.record.expand),\n          s = Object.assign({}, this.client.authStore.record, e);\n        t && (s.expand = Object.assign(t, e.expand)), this.client.authStore.save(this.client.authStore.token, s);\n      }\n      return e;\n    });\n  }\n  async delete(e, t) {\n    return super.delete(e, t).then(t => {\n      var _this$client$authStor4, _this$client$authStor5, _this$client$authStor6;\n      return !t || ((_this$client$authStor4 = this.client.authStore.record) === null || _this$client$authStor4 === void 0 ? void 0 : _this$client$authStor4.id) !== e || ((_this$client$authStor5 = this.client.authStore.record) === null || _this$client$authStor5 === void 0 ? void 0 : _this$client$authStor5.collectionId) !== this.collectionIdOrName && ((_this$client$authStor6 = this.client.authStore.record) === null || _this$client$authStor6 === void 0 ? void 0 : _this$client$authStor6.collectionName) !== this.collectionIdOrName || this.client.authStore.clear(), t;\n    });\n  }\n  authResponse(e) {\n    const t = this.decode((e === null || e === void 0 ? void 0 : e.record) || {});\n    return this.client.authStore.save(e === null || e === void 0 ? void 0 : e.token, t), Object.assign({}, e, {\n      token: (e === null || e === void 0 ? void 0 : e.token) || \"\",\n      record: t\n    });\n  }\n  async listAuthMethods(e) {\n    return e = Object.assign({\n      method: \"GET\",\n      fields: \"mfa,otp,password,oauth2\"\n    }, e), this.client.send(this.baseCollectionPath + \"/auth-methods\", e);\n  }\n  async authWithPassword(e, t, s) {\n    let i;\n    s = Object.assign({\n      method: \"POST\",\n      body: {\n        identity: e,\n        password: t\n      }\n    }, s), this.isSuperusers && (i = s.autoRefreshThreshold, delete s.autoRefreshThreshold, s.autoRefresh || resetAutoRefresh(this.client));\n    let n = await this.client.send(this.baseCollectionPath + \"/auth-with-password\", s);\n    return n = this.authResponse(n), i && this.isSuperusers && function registerAutoRefresh(e, t, s, i) {\n      resetAutoRefresh(e);\n      const n = e.beforeSend,\n        r = e.authStore.record,\n        o = e.authStore.onChange((t, s) => {\n          (!t || (s === null || s === void 0 ? void 0 : s.id) != (r === null || r === void 0 ? void 0 : r.id) || ((s === null || s === void 0 ? void 0 : s.collectionId) || (r === null || r === void 0 ? void 0 : r.collectionId)) && (s === null || s === void 0 ? void 0 : s.collectionId) != (r === null || r === void 0 ? void 0 : r.collectionId)) && resetAutoRefresh(e);\n        });\n      e._resetAutoRefresh = function () {\n        o(), e.beforeSend = n, delete e._resetAutoRefresh;\n      }, e.beforeSend = async (r, o) => {\n        var _o$query;\n        const a = e.authStore.token;\n        if ((_o$query = o.query) !== null && _o$query !== void 0 && _o$query.autoRefresh) return n ? n(r, o) : {\n          url: r,\n          sendOptions: o\n        };\n        let c = e.authStore.isValid;\n        if (c && isTokenExpired(e.authStore.token, t)) try {\n          await s();\n        } catch (e) {\n          c = !1;\n        }\n        c || (await i());\n        const l = o.headers || {};\n        for (let t in l) if (\"authorization\" == t.toLowerCase() && a == l[t] && e.authStore.token) {\n          l[t] = e.authStore.token;\n          break;\n        }\n        return o.headers = l, n ? n(r, o) : {\n          url: r,\n          sendOptions: o\n        };\n      };\n    }(this.client, i, () => this.authRefresh({\n      autoRefresh: !0\n    }), () => this.authWithPassword(e, t, Object.assign({\n      autoRefresh: !0\n    }, s))), n;\n  }\n  async authWithOAuth2Code(e, t, s, i, n, r, o) {\n    let a = {\n      method: \"POST\",\n      body: {\n        provider: e,\n        code: t,\n        codeVerifier: s,\n        redirectURL: i,\n        createData: n\n      }\n    };\n    return a = normalizeLegacyOptionsArgs(\"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, options?).\", a, r, o), this.client.send(this.baseCollectionPath + \"/auth-with-oauth2\", a).then(e => this.authResponse(e));\n  }\n  authWithOAuth2() {\n    for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n      e[_key] = arguments[_key];\n    }\n    if (e.length > 1 || \"string\" == typeof (e === null || e === void 0 ? void 0 : e[0])) return console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\"), this.authWithOAuth2Code((e === null || e === void 0 ? void 0 : e[0]) || \"\", (e === null || e === void 0 ? void 0 : e[1]) || \"\", (e === null || e === void 0 ? void 0 : e[2]) || \"\", (e === null || e === void 0 ? void 0 : e[3]) || \"\", (e === null || e === void 0 ? void 0 : e[4]) || {}, (e === null || e === void 0 ? void 0 : e[5]) || {}, (e === null || e === void 0 ? void 0 : e[6]) || {});\n    const t = (e === null || e === void 0 ? void 0 : e[0]) || {};\n    let s = null;\n    t.urlCallback || (s = openBrowserPopup(void 0));\n    const i = new RealtimeService(this.client);\n    function cleanup() {\n      var _s;\n      (_s = s) !== null && _s !== void 0 && _s.close(), i.unsubscribe();\n    }\n    const n = {},\n      r = t.requestKey;\n    return r && (n.requestKey = r), this.listAuthMethods(n).then(e => {\n      var _this$client$cancelCo;\n      const n = e.oauth2.providers.find(e => e.name === t.provider);\n      if (!n) throw new ClientResponseError(new Error(\"Missing or invalid provider \\\"\".concat(t.provider, \"\\\".\")));\n      const o = this.client.buildURL(\"/api/oauth2-redirect\"),\n        a = r ? (_this$client$cancelCo = this.client.cancelControllers) === null || _this$client$cancelCo === void 0 ? void 0 : _this$client$cancelCo[r] : void 0;\n      return a && (a.signal.onabort = () => {\n        cleanup();\n      }), new Promise(async (e, r) => {\n        try {\n          var _t$scopes;\n          await i.subscribe(\"@oauth2\", async s => {\n            const c = i.clientId;\n            try {\n              var _a$signal;\n              if (!s.state || c !== s.state) throw new Error(\"State parameters don't match.\");\n              if (s.error || !s.code) throw new Error(\"OAuth2 redirect error or missing code: \" + s.error);\n              const i = Object.assign({}, t);\n              delete i.provider, delete i.scopes, delete i.createData, delete i.urlCallback, (a === null || a === void 0 || (_a$signal = a.signal) === null || _a$signal === void 0 ? void 0 : _a$signal.onabort) && (a.signal.onabort = null);\n              const r = await this.authWithOAuth2Code(n.name, s.code, n.codeVerifier, o, t.createData, i);\n              e(r);\n            } catch (e) {\n              r(new ClientResponseError(e));\n            }\n            cleanup();\n          });\n          const c = {\n            state: i.clientId\n          };\n          ((_t$scopes = t.scopes) === null || _t$scopes === void 0 ? void 0 : _t$scopes.length) && (c.scope = t.scopes.join(\" \"));\n          const l = this._replaceQueryParams(n.authURL + o, c);\n          let h = t.urlCallback || function (e) {\n            s ? s.location.href = e : s = openBrowserPopup(e);\n          };\n          await h(l);\n        } catch (e) {\n          cleanup(), r(new ClientResponseError(e));\n        }\n      });\n    }).catch(e => {\n      throw cleanup(), e;\n    });\n  }\n  async authRefresh(e, t) {\n    let s = {\n      method: \"POST\"\n    };\n    return s = normalizeLegacyOptionsArgs(\"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\", s, e, t), this.client.send(this.baseCollectionPath + \"/auth-refresh\", s).then(e => this.authResponse(e));\n  }\n  async requestPasswordReset(e, t, s) {\n    let i = {\n      method: \"POST\",\n      body: {\n        email: e\n      }\n    };\n    return i = normalizeLegacyOptionsArgs(\"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-password-reset\", i).then(() => !0);\n  }\n  async confirmPasswordReset(e, t, s, i, n) {\n    let r = {\n      method: \"POST\",\n      body: {\n        token: e,\n        password: t,\n        passwordConfirm: s\n      }\n    };\n    return r = normalizeLegacyOptionsArgs(\"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\", r, i, n), this.client.send(this.baseCollectionPath + \"/confirm-password-reset\", r).then(() => !0);\n  }\n  async requestVerification(e, t, s) {\n    let i = {\n      method: \"POST\",\n      body: {\n        email: e\n      }\n    };\n    return i = normalizeLegacyOptionsArgs(\"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-verification\", i).then(() => !0);\n  }\n  async confirmVerification(e, t, s) {\n    let i = {\n      method: \"POST\",\n      body: {\n        token: e\n      }\n    };\n    return i = normalizeLegacyOptionsArgs(\"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/confirm-verification\", i).then(() => {\n      const t = getTokenPayload(e),\n        s = this.client.authStore.record;\n      return s && !s.verified && s.id === t.id && s.collectionId === t.collectionId && (s.verified = !0, this.client.authStore.save(this.client.authStore.token, s)), !0;\n    });\n  }\n  async requestEmailChange(e, t, s) {\n    let i = {\n      method: \"POST\",\n      body: {\n        newEmail: e\n      }\n    };\n    return i = normalizeLegacyOptionsArgs(\"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\", i, t, s), this.client.send(this.baseCollectionPath + \"/request-email-change\", i).then(() => !0);\n  }\n  async confirmEmailChange(e, t, s, i) {\n    let n = {\n      method: \"POST\",\n      body: {\n        token: e,\n        password: t\n      }\n    };\n    return n = normalizeLegacyOptionsArgs(\"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\", n, s, i), this.client.send(this.baseCollectionPath + \"/confirm-email-change\", n).then(() => {\n      const t = getTokenPayload(e),\n        s = this.client.authStore.record;\n      return s && s.id === t.id && s.collectionId === t.collectionId && this.client.authStore.clear(), !0;\n    });\n  }\n  async listExternalAuths(e, t) {\n    return this.client.collection(\"_externalAuths\").getFullList(Object.assign({}, t, {\n      filter: this.client.filter(\"recordRef = {:id}\", {\n        id: e\n      })\n    }));\n  }\n  async unlinkExternalAuth(e, t, s) {\n    const i = await this.client.collection(\"_externalAuths\").getFirstListItem(this.client.filter(\"recordRef = {:recordId} && provider = {:provider}\", {\n      recordId: e,\n      provider: t\n    }));\n    return this.client.collection(\"_externalAuths\").delete(i.id, s).then(() => !0);\n  }\n  async requestOTP(e, t) {\n    return t = Object.assign({\n      method: \"POST\",\n      body: {\n        email: e\n      }\n    }, t), this.client.send(this.baseCollectionPath + \"/request-otp\", t);\n  }\n  async authWithOTP(e, t, s) {\n    return s = Object.assign({\n      method: \"POST\",\n      body: {\n        otpId: e,\n        password: t\n      }\n    }, s), this.client.send(this.baseCollectionPath + \"/auth-with-otp\", s).then(e => this.authResponse(e));\n  }\n  async impersonate(e, t, s) {\n    (s = Object.assign({\n      method: \"POST\",\n      body: {\n        duration: t\n      }\n    }, s)).headers = s.headers || {}, s.headers.Authorization || (s.headers.Authorization = this.client.authStore.token);\n    const i = new Client(this.client.baseURL, new BaseAuthStore(), this.client.lang),\n      n = await i.send(this.baseCollectionPath + \"/impersonate/\" + encodeURIComponent(e), s);\n    return i.authStore.save(n === null || n === void 0 ? void 0 : n.token, this.decode((n === null || n === void 0 ? void 0 : n.record) || {})), i;\n  }\n  _replaceQueryParams(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let s = e,\n      i = \"\";\n    e.indexOf(\"?\") >= 0 && (s = e.substring(0, e.indexOf(\"?\")), i = e.substring(e.indexOf(\"?\") + 1));\n    const n = {},\n      r = i.split(\"&\");\n    for (const e of r) {\n      if (\"\" == e) continue;\n      const t = e.split(\"=\");\n      n[decodeURIComponent(t[0].replace(/\\+/g, \" \"))] = decodeURIComponent((t[1] || \"\").replace(/\\+/g, \" \"));\n    }\n    for (let e in t) t.hasOwnProperty(e) && (null == t[e] ? delete n[e] : n[e] = t[e]);\n    i = \"\";\n    for (let e in n) n.hasOwnProperty(e) && (\"\" != i && (i += \"&\"), i += encodeURIComponent(e.replace(/%20/g, \"+\")) + \"=\" + encodeURIComponent(n[e].replace(/%20/g, \"+\")));\n    return \"\" != i ? s + \"?\" + i : s;\n  }\n}\nfunction openBrowserPopup(e) {\n  var _window5;\n  if (\"undefined\" == typeof window || !((_window5 = window) !== null && _window5 !== void 0 && _window5.open)) throw new ClientResponseError(new Error(\"Not in a browser context - please pass a custom urlCallback function.\"));\n  let t = 1024,\n    s = 768,\n    i = window.innerWidth,\n    n = window.innerHeight;\n  t = t > i ? i : t, s = s > n ? n : s;\n  let r = i / 2 - t / 2,\n    o = n / 2 - s / 2;\n  return window.open(e, \"popup_window\", \"width=\" + t + \",height=\" + s + \",top=\" + o + \",left=\" + r + \",resizable,menubar=no\");\n}\nclass CollectionService extends CrudService {\n  get baseCrudPath() {\n    return \"/api/collections\";\n  }\n  async import(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    return s = Object.assign({\n      method: \"PUT\",\n      body: {\n        collections: e,\n        deleteMissing: t\n      }\n    }, s), this.client.send(this.baseCrudPath + \"/import\", s).then(() => !0);\n  }\n  async getScaffolds(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(this.baseCrudPath + \"/meta/scaffolds\", e);\n  }\n  async truncate(e, t) {\n    return t = Object.assign({\n      method: \"DELETE\"\n    }, t), this.client.send(this.baseCrudPath + \"/\" + encodeURIComponent(e) + \"/truncate\", t).then(() => !0);\n  }\n}\nclass LogService extends BaseService {\n  async getList() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    return (s = Object.assign({\n      method: \"GET\"\n    }, s)).query = Object.assign({\n      page: e,\n      perPage: t\n    }, s.query), this.client.send(\"/api/logs\", s);\n  }\n  async getOne(e, t) {\n    if (!e) throw new ClientResponseError({\n      url: this.client.buildURL(\"/api/logs/\"),\n      status: 404,\n      response: {\n        code: 404,\n        message: \"Missing required log id.\",\n        data: {}\n      }\n    });\n    return t = Object.assign({\n      method: \"GET\"\n    }, t), this.client.send(\"/api/logs/\" + encodeURIComponent(e), t);\n  }\n  async getStats(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(\"/api/logs/stats\", e);\n  }\n}\nclass HealthService extends BaseService {\n  async check(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(\"/api/health\", e);\n  }\n}\nclass FileService extends BaseService {\n  getUrl(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return console.warn(\"Please replace pb.files.getUrl() with pb.files.getURL()\"), this.getURL(e, t, s);\n  }\n  getURL(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!t || !(e !== null && e !== void 0 && e.id) || !(e !== null && e !== void 0 && e.collectionId) && !(e !== null && e !== void 0 && e.collectionName)) return \"\";\n    const i = [];\n    i.push(\"api\"), i.push(\"files\"), i.push(encodeURIComponent(e.collectionId || e.collectionName)), i.push(encodeURIComponent(e.id)), i.push(encodeURIComponent(t));\n    let n = this.client.buildURL(i.join(\"/\"));\n    if (Object.keys(s).length) {\n      !1 === s.download && delete s.download;\n      const e = new URLSearchParams(s);\n      n += (n.includes(\"?\") ? \"&\" : \"?\") + e;\n    }\n    return n;\n  }\n  async getToken(e) {\n    return e = Object.assign({\n      method: \"POST\"\n    }, e), this.client.send(\"/api/files/token\", e).then(e => (e === null || e === void 0 ? void 0 : e.token) || \"\");\n  }\n}\nclass BackupService extends BaseService {\n  async getFullList(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(\"/api/backups\", e);\n  }\n  async create(e, t) {\n    return t = Object.assign({\n      method: \"POST\",\n      body: {\n        name: e\n      }\n    }, t), this.client.send(\"/api/backups\", t).then(() => !0);\n  }\n  async upload(e, t) {\n    return t = Object.assign({\n      method: \"POST\",\n      body: e\n    }, t), this.client.send(\"/api/backups/upload\", t).then(() => !0);\n  }\n  async delete(e, t) {\n    return t = Object.assign({\n      method: \"DELETE\"\n    }, t), this.client.send(\"/api/backups/\".concat(encodeURIComponent(e)), t).then(() => !0);\n  }\n  async restore(e, t) {\n    return t = Object.assign({\n      method: \"POST\"\n    }, t), this.client.send(\"/api/backups/\".concat(encodeURIComponent(e), \"/restore\"), t).then(() => !0);\n  }\n  getDownloadUrl(e, t) {\n    return console.warn(\"Please replace pb.backups.getDownloadUrl() with pb.backups.getDownloadURL()\"), this.getDownloadURL(e, t);\n  }\n  getDownloadURL(e, t) {\n    return this.client.buildURL(\"/api/backups/\".concat(encodeURIComponent(t), \"?token=\").concat(encodeURIComponent(e)));\n  }\n}\nclass CronService extends BaseService {\n  async getFullList(e) {\n    return e = Object.assign({\n      method: \"GET\"\n    }, e), this.client.send(\"/api/crons\", e);\n  }\n  async run(e, t) {\n    return t = Object.assign({\n      method: \"POST\"\n    }, t), this.client.send(\"/api/crons/\".concat(encodeURIComponent(e)), t).then(() => !0);\n  }\n}\nfunction isFile(e) {\n  return \"undefined\" != typeof Blob && e instanceof Blob || \"undefined\" != typeof File && e instanceof File || null !== e && \"object\" == typeof e && e.uri && (\"undefined\" != typeof navigator && \"ReactNative\" === navigator.product || \"undefined\" != typeof global && global.HermesInternal);\n}\nfunction isFormData(e) {\n  return e && (\"FormData\" === e.constructor.name || \"undefined\" != typeof FormData && e instanceof FormData);\n}\nfunction hasFileField(e) {\n  for (const t in e) {\n    const s = Array.isArray(e[t]) ? e[t] : [e[t]];\n    for (const e of s) if (isFile(e)) return !0;\n  }\n  return !1;\n}\nconst r = /^[\\-\\.\\d]+$/;\nfunction inferFormDataValue(e) {\n  if (\"string\" != typeof e) return e;\n  if (\"true\" == e) return !0;\n  if (\"false\" == e) return !1;\n  if ((\"-\" === e[0] || e[0] >= \"0\" && e[0] <= \"9\") && r.test(e)) {\n    let t = +e;\n    if (\"\" + t === e) return t;\n  }\n  return e;\n}\nclass BatchService extends BaseService {\n  constructor() {\n    super(...arguments), this.requests = [], this.subs = {};\n  }\n  collection(e) {\n    return this.subs[e] || (this.subs[e] = new SubBatchService(this.requests, e)), this.subs[e];\n  }\n  async send(e) {\n    const t = new FormData(),\n      s = [];\n    for (let e = 0; e < this.requests.length; e++) {\n      const i = this.requests[e];\n      if (s.push({\n        method: i.method,\n        url: i.url,\n        headers: i.headers,\n        body: i.json\n      }), i.files) for (let s in i.files) {\n        const n = i.files[s] || [];\n        for (let i of n) t.append(\"requests.\" + e + \".\" + s, i);\n      }\n    }\n    return t.append(\"@jsonPayload\", JSON.stringify({\n      requests: s\n    })), e = Object.assign({\n      method: \"POST\",\n      body: t\n    }, e), this.client.send(\"/api/batch\", e);\n  }\n}\nclass SubBatchService {\n  constructor(e, t) {\n    this.requests = [], this.requests = e, this.collectionIdOrName = t;\n  }\n  upsert(e, t) {\n    t = Object.assign({\n      body: e || {}\n    }, t);\n    const s = {\n      method: \"PUT\",\n      url: \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName) + \"/records\"\n    };\n    this.prepareRequest(s, t), this.requests.push(s);\n  }\n  create(e, t) {\n    t = Object.assign({\n      body: e || {}\n    }, t);\n    const s = {\n      method: \"POST\",\n      url: \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName) + \"/records\"\n    };\n    this.prepareRequest(s, t), this.requests.push(s);\n  }\n  update(e, t, s) {\n    s = Object.assign({\n      body: t || {}\n    }, s);\n    const i = {\n      method: \"PATCH\",\n      url: \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName) + \"/records/\" + encodeURIComponent(e)\n    };\n    this.prepareRequest(i, s), this.requests.push(i);\n  }\n  delete(e, t) {\n    t = Object.assign({}, t);\n    const s = {\n      method: \"DELETE\",\n      url: \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName) + \"/records/\" + encodeURIComponent(e)\n    };\n    this.prepareRequest(s, t), this.requests.push(s);\n  }\n  prepareRequest(e, t) {\n    if (normalizeUnknownQueryParams(t), e.headers = t.headers, e.json = {}, e.files = {}, void 0 !== t.query) {\n      const s = serializeQueryParams(t.query);\n      s && (e.url += (e.url.includes(\"?\") ? \"&\" : \"?\") + s);\n    }\n    let s = t.body;\n    isFormData(s) && (s = function convertFormDataToObject(e) {\n      let t = {};\n      return e.forEach((e, s) => {\n        if (\"@jsonPayload\" === s && \"string\" == typeof e) try {\n          let s = JSON.parse(e);\n          Object.assign(t, s);\n        } catch (e) {\n          console.warn(\"@jsonPayload error:\", e);\n        } else void 0 !== t[s] ? (Array.isArray(t[s]) || (t[s] = [t[s]]), t[s].push(inferFormDataValue(e))) : t[s] = inferFormDataValue(e);\n      }), t;\n    }(s));\n    for (const t in s) {\n      const i = s[t];\n      if (isFile(i)) e.files[t] = e.files[t] || [], e.files[t].push(i);else if (Array.isArray(i)) {\n        const s = [],\n          n = [];\n        for (const e of i) isFile(e) ? s.push(e) : n.push(e);\n        if (s.length > 0 && s.length == i.length) {\n          e.files[t] = e.files[t] || [];\n          for (let i of s) e.files[t].push(i);\n        } else if (e.json[t] = n, s.length > 0) {\n          let i = t;\n          t.startsWith(\"+\") || t.endsWith(\"+\") || (i += \"+\"), e.files[i] = e.files[i] || [];\n          for (let t of s) e.files[i].push(t);\n        }\n      } else e.json[t] = i;\n    }\n  }\n}\nclass Client {\n  get baseUrl() {\n    return this.baseURL;\n  }\n  set baseUrl(e) {\n    this.baseURL = e;\n  }\n  constructor() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"en-US\";\n    this.cancelControllers = {}, this.recordServices = {}, this.enableAutoCancellation = !0, this.baseURL = e, this.lang = s, t ? this.authStore = t : \"undefined\" != typeof window && window.Deno ? this.authStore = new BaseAuthStore() : this.authStore = new LocalAuthStore(), this.collections = new CollectionService(this), this.files = new FileService(this), this.logs = new LogService(this), this.settings = new SettingsService(this), this.realtime = new RealtimeService(this), this.health = new HealthService(this), this.backups = new BackupService(this), this.crons = new CronService(this);\n  }\n  get admins() {\n    return this.collection(\"_superusers\");\n  }\n  createBatch() {\n    return new BatchService(this);\n  }\n  collection(e) {\n    return this.recordServices[e] || (this.recordServices[e] = new RecordService(this, e)), this.recordServices[e];\n  }\n  autoCancellation(e) {\n    return this.enableAutoCancellation = !!e, this;\n  }\n  cancelRequest(e) {\n    return this.cancelControllers[e] && (this.cancelControllers[e].abort(), delete this.cancelControllers[e]), this;\n  }\n  cancelAllRequests() {\n    for (let e in this.cancelControllers) this.cancelControllers[e].abort();\n    return this.cancelControllers = {}, this;\n  }\n  filter(e, t) {\n    if (!t) return e;\n    for (let s in t) {\n      let i = t[s];\n      switch (typeof i) {\n        case \"boolean\":\n        case \"number\":\n          i = \"\" + i;\n          break;\n        case \"string\":\n          i = \"'\" + i.replace(/'/g, \"\\\\'\") + \"'\";\n          break;\n        default:\n          i = null === i ? \"null\" : i instanceof Date ? \"'\" + i.toISOString().replace(\"T\", \" \") + \"'\" : \"'\" + JSON.stringify(i).replace(/'/g, \"\\\\'\") + \"'\";\n      }\n      e = e.replaceAll(\"{:\" + s + \"}\", i);\n    }\n    return e;\n  }\n  getFileUrl(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return console.warn(\"Please replace pb.getFileUrl() with pb.files.getURL()\"), this.files.getURL(e, t, s);\n  }\n  buildUrl(e) {\n    return console.warn(\"Please replace pb.buildUrl() with pb.buildURL()\"), this.buildURL(e);\n  }\n  buildURL(e) {\n    var _window$location$orig;\n    let t = this.baseURL;\n    return \"undefined\" == typeof window || !window.location || t.startsWith(\"https://\") || t.startsWith(\"http://\") || (t = (_window$location$orig = window.location.origin) !== null && _window$location$orig !== void 0 && _window$location$orig.endsWith(\"/\") ? window.location.origin.substring(0, window.location.origin.length - 1) : window.location.origin || \"\", this.baseURL.startsWith(\"/\") || (t += window.location.pathname || \"/\", t += t.endsWith(\"/\") ? \"\" : \"/\"), t += this.baseURL), e && (t += t.endsWith(\"/\") ? \"\" : \"/\", t += e.startsWith(\"/\") ? e.substring(1) : e), t;\n  }\n  async send(e, t) {\n    t = this.initSendOptions(e, t);\n    let s = this.buildURL(e);\n    if (this.beforeSend) {\n      var _console;\n      const e = Object.assign({}, await this.beforeSend(s, t));\n      void 0 !== e.url || void 0 !== e.options ? (s = e.url || s, t = e.options || t) : Object.keys(e).length && (t = e, ((_console = console) === null || _console === void 0 ? void 0 : _console.warn) && console.warn(\"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\"));\n    }\n    if (void 0 !== t.query) {\n      const e = serializeQueryParams(t.query);\n      e && (s += (s.includes(\"?\") ? \"&\" : \"?\") + e), delete t.query;\n    }\n    \"application/json\" == this.getHeader(t.headers, \"Content-Type\") && t.body && \"string\" != typeof t.body && (t.body = JSON.stringify(t.body));\n    return (t.fetch || fetch)(s, t).then(async e => {\n      let s = {};\n      try {\n        s = await e.json();\n      } catch (e) {}\n      if (this.afterSend && (s = await this.afterSend(e, s, t)), e.status >= 400) throw new ClientResponseError({\n        url: e.url,\n        status: e.status,\n        data: s\n      });\n      return s;\n    }).catch(e => {\n      throw new ClientResponseError(e);\n    });\n  }\n  initSendOptions(e, t) {\n    if ((t = Object.assign({\n      method: \"GET\"\n    }, t)).body = function convertToFormDataIfNeeded(e) {\n      if (\"undefined\" == typeof FormData || void 0 === e || \"object\" != typeof e || null === e || isFormData(e) || !hasFileField(e)) return e;\n      const t = new FormData();\n      for (const s in e) {\n        const i = e[s];\n        if (void 0 !== i) if (\"object\" != typeof i || hasFileField({\n          data: i\n        })) {\n          const e = Array.isArray(i) ? i : [i];\n          for (let i of e) t.append(s, i);\n        } else {\n          let e = {};\n          e[s] = i, t.append(\"@jsonPayload\", JSON.stringify(e));\n        }\n      }\n      return t;\n    }(t.body), normalizeUnknownQueryParams(t), t.query = Object.assign({}, t.params, t.query), void 0 === t.requestKey && (!1 === t.$autoCancel || !1 === t.query.$autoCancel ? t.requestKey = null : (t.$cancelKey || t.query.$cancelKey) && (t.requestKey = t.$cancelKey || t.query.$cancelKey)), delete t.$autoCancel, delete t.query.$autoCancel, delete t.$cancelKey, delete t.query.$cancelKey, null !== this.getHeader(t.headers, \"Content-Type\") || isFormData(t.body) || (t.headers = Object.assign({}, t.headers, {\n      \"Content-Type\": \"application/json\"\n    })), null === this.getHeader(t.headers, \"Accept-Language\") && (t.headers = Object.assign({}, t.headers, {\n      \"Accept-Language\": this.lang\n    })), this.authStore.token && null === this.getHeader(t.headers, \"Authorization\") && (t.headers = Object.assign({}, t.headers, {\n      Authorization: this.authStore.token\n    })), this.enableAutoCancellation && null !== t.requestKey) {\n      const s = t.requestKey || (t.method || \"GET\") + e;\n      delete t.requestKey, this.cancelRequest(s);\n      const i = new AbortController();\n      this.cancelControllers[s] = i, t.signal = i.signal;\n    }\n    return t;\n  }\n  getHeader(e, t) {\n    e = e || {}, t = t.toLowerCase();\n    for (let s in e) if (s.toLowerCase() == t) return e[s];\n    return null;\n  }\n}\nclass AsyncAuthStore extends BaseAuthStore {\n  constructor(e) {\n    super(), this.queue = [], this.saveFunc = e.save, this.clearFunc = e.clear, this._enqueue(() => this._loadInitial(e.initial));\n  }\n  save(e, t) {\n    super.save(e, t);\n    let s = \"\";\n    try {\n      s = JSON.stringify({\n        token: e,\n        record: t\n      });\n    } catch (e) {\n      console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n    }\n    this._enqueue(() => this.saveFunc(s));\n  }\n  clear() {\n    super.clear(), this.clearFunc ? this._enqueue(() => this.clearFunc()) : this._enqueue(() => this.saveFunc(\"\"));\n  }\n  async _loadInitial(e) {\n    try {\n      if (e = await e) {\n        let t;\n        \"string\" == typeof e ? t = JSON.parse(e) || {} : \"object\" == typeof e && (t = e), this.save(t.token || \"\", t.record || t.model || null);\n      }\n    } catch (e) {}\n  }\n  _enqueue(e) {\n    this.queue.push(e), 1 == this.queue.length && this._dequeue();\n  }\n  _dequeue() {\n    this.queue.length && this.queue[0]().finally(() => {\n      this.queue.shift(), this.queue.length && this._dequeue();\n    });\n  }\n}\nexport { AsyncAuthStore, BaseAuthStore, BatchService, ClientResponseError, CollectionService, CrudService, HealthService, LocalAuthStore, LogService, RealtimeService, RecordService, SubBatchService, cookieParse, cookieSerialize, Client as default, getTokenPayload, isTokenExpired, normalizeUnknownQueryParams, serializeQueryParams };","map":{"version":3,"names":["ClientResponseError","Error","constructor","e","_this$response","_this$originalError","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","message","cause","includes","toJSON","_objectSpread","cookieParse","t","s","i","assign","decode","defaultDecode","n","length","indexOf","r","lastIndexOf","o","slice","trim","charCodeAt","cookieSerialize","encode","defaultEncode","test","TypeError","a","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","decodeURIComponent","encodeURIComponent","navigator","product","global","HermesInternal","getTokenPayload","split","map","join","JSON","parse","isTokenExpired","arguments","undefined","keys","exp","now","atob","String","replace","charAt","fromCharCode","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","token","record","model","isValid","isSuperuser","_this$record","_this$record2","type","collectionName","collectionId","isAdmin","console","warn","isAuthRecord","save","triggerChange","clear","loadFromCookie","Array","isArray","exportToCookie","stringify","Blob","size","_r$record","_r$record2","id","email","onChange","push","splice","LocalAuthStore","storageFallback","storageKey","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","_window","window","localStorage","getItem","_window2","setItem","_window3","_window$localStorage","removeItem","_window4","addEventListener","key","BaseService","client","SettingsService","getAll","method","send","update","body","testS3","filesystem","then","testEmail","template","collection","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","normalizeUnknownQueryParams","query","serializeQueryParams","prepareQueryParamValue","toISOString","RealtimeService","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","_this$eventSource","headers","listener","_unused","submitSubscriptions","connect","unsubscribeByTopicAndListener","unsubscribe","getSubscriptionsByTopic","hasSubscriptionListeners","_this$eventSource2","removeEventListener","disconnect","unsubscribeByPrefix","startsWith","_this$eventSource3","_this$eventSource4","_this$subscriptions$e","_this$subscriptions$e2","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","requestKey","getSubscriptionsCancelKey","catch","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","buildURL","onerror","lastEventId","hasUnsentSubscriptions","reconnectTimeoutId","_this$eventSource5","onDisconnect","cancelRequest","close","CrudService","getFullList","_getFullList","batch","getList","page","perPage","baseCrudPath","_e$items","items","getFirstListItem","filter","skipTotal","_e$items2","code","getOne","create","delete","request","concat","normalizeLegacyOptionsArgs","resetAutoRefresh","_e$_resetAutoRefresh","_resetAutoRefresh","RecordService","collectionIdOrName","baseCollectionPath","isSuperusers","realtime","_this$client$authStor","_this$client$authStor2","_this$client$authStor3","authStore","expand","_this$client$authStor4","_this$client$authStor5","_this$client$authStor6","authResponse","listAuthMethods","fields","authWithPassword","identity","password","autoRefreshThreshold","autoRefresh","registerAutoRefresh","beforeSend","_o$query","sendOptions","c","l","authRefresh","authWithOAuth2Code","provider","codeVerifier","redirectURL","createData","authWithOAuth2","_len","_key","urlCallback","openBrowserPopup","cleanup","_s","_this$client$cancelCo","oauth2","providers","find","cancelControllers","signal","onabort","_t$scopes","_a$signal","state","error","scopes","scope","_replaceQueryParams","authURL","h","location","href","requestPasswordReset","confirmPasswordReset","passwordConfirm","requestVerification","confirmVerification","verified","requestEmailChange","newEmail","confirmEmailChange","listExternalAuths","unlinkExternalAuth","recordId","requestOTP","authWithOTP","otpId","impersonate","Authorization","Client","baseURL","lang","substring","hasOwnProperty","_window5","open","innerWidth","innerHeight","CollectionService","import","collections","deleteMissing","getScaffolds","truncate","LogService","getStats","HealthService","check","FileService","getUrl","getURL","download","URLSearchParams","getToken","BackupService","upload","restore","getDownloadUrl","getDownloadURL","CronService","run","isFile","File","uri","isFormData","FormData","hasFileField","inferFormDataValue","BatchService","requests","subs","SubBatchService","json","files","append","upsert","prepareRequest","convertFormDataToObject","forEach","endsWith","baseUrl","recordServices","enableAutoCancellation","Deno","logs","settings","health","backups","crons","admins","createBatch","autoCancellation","abort","cancelAllRequests","replaceAll","getFileUrl","buildUrl","_window$location$orig","origin","pathname","initSendOptions","_console","options","getHeader","fetch","afterSend","convertToFormDataIfNeeded","params","$autoCancel","$cancelKey","AbortController","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","_dequeue","finally","shift","default"],"sources":["/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/ClientResponseError.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/cookie.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/jwt.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/stores/BaseAuthStore.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/stores/LocalAuthStore.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/BaseService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/SettingsService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/options.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/RealtimeService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/CrudService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/legacy.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/refresh.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/RecordService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/CollectionService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/LogService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/HealthService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/FileService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/BackupService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/CronService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/tools/formdata.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/services/BatchService.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/Client.ts","/home/ubuntu/Documents/myLearning/portfolio/node_modules/pocketbase/src/stores/AsyncAuthStore.ts"],"sourcesContent":["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string = \"\";\n    status: number = 0;\n    response: { [key: string]: any } = {};\n    isAbort: boolean = false;\n    originalError: any = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === \"object\") {\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\n            this.isAbort = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === \"object\") {\n                this.response = errData.response;\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\n                this.response = errData.data;\n            } else {\n                this.response = {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== \"undefined\" && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message =\n                    \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\";\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message =\n                    \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\";\n            } else {\n                this.message = \"Something went wrong.\";\n            }\n        }\n\n        // set this.cause so that JS debugging tools can automatically connect\n        // the dots between the original error and the wrapped one\n        this.cause = this.originalError;\n    }\n\n    /**\n     * Alias for `this.response` for backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions {\n    decode?: (val: string) => string;\n}\n\n/**\n * Parses the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== \"string\") {\n        return result;\n    }\n\n    const opt = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf(\"=\", index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(\";\", index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n}\n\nexport interface SerializeOptions {\n    encode?: (val: string | number | boolean) => string;\n    maxAge?: number;\n    domain?: string;\n    path?: string;\n    expires?: Date;\n    httpOnly?: boolean;\n    secure?: boolean;\n    priority?: string;\n    sameSite?: boolean | string;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(\n    name: string,\n    val: string,\n    options?: SerializeOptions,\n): string {\n    const opt = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n\n    let result = name + \"=\" + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n\n        result += \"; Max-Age=\" + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n\n        result += \"; Domain=\" + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n\n        result += \"; Path=\" + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n\n        result += \"; Expires=\" + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += \"; HttpOnly\";\n    }\n\n    if (opt.secure) {\n        result += \"; Secure\";\n    }\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case \"low\":\n                result += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                result += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                result += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                result += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                result += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                result += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n\n    return result;\n}\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n","// @todo remove after https://github.com/reactwg/react-native-releases/issues/287\nconst isReactNative =\n    (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n    (typeof global !== \"undefined\" && (global as any).HermesInternal);\n\nlet atobPolyfill: Function;\nif (typeof atob === \"function\" && !isReactNative) {\n    atobPolyfill = atob;\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\n            );\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(\n                atobPolyfill(token.split(\".\")[1])\n                    .split(\"\")\n                    .map(function (c: string) {\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                    })\n                    .join(\"\"),\n            );\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {}\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/tools/cookie\";\nimport { isTokenExpired, getTokenPayload } from \"@/tools/jwt\";\nimport { RecordModel } from \"@/tools/dtos\";\n\nexport type AuthRecord = RecordModel | null;\n\nexport type AuthModel = AuthRecord; // for backward compatibility\n\nexport type OnStoreChangeFunc = (token: string, record: AuthRecord) => void;\n\nconst defaultCookieKey = \"pb_auth\";\n\n/**\n * Base AuthStore class that stores the auth state in runtime memory (aka. only for the duration of the store instane).\n *\n * Usually you wouldn't use it directly and instead use the builtin LocalAuthStore, AsyncAuthStore\n * or extend it with your own custom implementation.\n */\nexport class BaseAuthStore {\n    protected baseToken: string = \"\";\n    protected baseModel: AuthRecord = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get record(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Loosely checks whether the currently loaded store state is for superuser.\n     *\n     * Alternatively you can also compare directly `pb.authStore.record?.collectionName`.\n     */\n    get isSuperuser(): boolean {\n        let payload = getTokenPayload(this.token);\n\n        return (\n            payload.type == \"auth\" &&\n            (this.record?.collectionName == \"_superusers\" ||\n                // fallback in case the record field is not populated and assuming\n                // that the collection crc32 checksum id wasn't manually changed\n                (!this.record?.collectionName &&\n                    payload.collectionId == \"pbc_3142635823\"))\n        );\n    }\n\n    /**\n     * @deprecated use `isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAdmin(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAdmin with pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return this.isSuperuser;\n    }\n\n    /**\n     * @deprecated use `!isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAuthRecord(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAuthRecord with !pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return getTokenPayload(this.token).type == \"auth\" && !this.isSuperuser;\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, record?: AuthRecord): void {\n        this.baseToken = token || \"\";\n        this.baseModel = record || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = \"\";\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || \"\", data.record || data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure: true,\n            sameSite: true,\n            httpOnly: true,\n            path: \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date(\"1970-01-01\");\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            record: this.record ? JSON.parse(JSON.stringify(this.record)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength =\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.record && resultLength > 4096) {\n            rawData.record = { id: rawData.record?.id, email: rawData.record?.email };\n            const extraProps = [\"collectionId\", \"collectionName\", \"verified\"];\n            for (const prop in this.record) {\n                if (extraProps.includes(prop)) {\n                    rawData.record[prop] = this.record[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.record);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i]; // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        };\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.record);\n        }\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (e.g. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string;\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || \"\";\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get record(): AuthRecord {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.record || data.model || null;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.record;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord) {\n        this._storageSet(this.storageKey, {\n            token: token,\n            record: record,\n        });\n\n        super.save(token, record);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || \"\";\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) {\n                // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== \"string\") {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (\n            typeof window === \"undefined\" ||\n            !window?.localStorage ||\n            !window.addEventListener\n        ) {\n            return;\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || \"\", data.record || data.model || null);\n        });\n    }\n}\n","import Client from \"@/Client\";\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     *\n     * @throws {ClientResponseError}\n     */\n    async testS3(\n        filesystem: string = \"storage\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    filesystem: filesystem,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     *\n     * @throws {ClientResponseError}\n     */\n    async testEmail(\n        collectionIdOrName: string,\n        toEmail: string,\n        emailTemplate: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    email: toEmail,\n                    template: emailTemplate,\n                    collection: collectionIdOrName,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     *\n     * @throws {ClientResponseError}\n     */\n    async generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    clientId,\n                    teamId,\n                    keyId,\n                    privateKey,\n                    duration,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\n    }\n}\n","export interface SendOptions extends RequestInit {\n    // for backward compatibility and to minimize the verbosity,\n    // any top-level field that doesn't exist in RequestInit or the\n    // fields below will be treated as query parameter.\n    [key: string]: any;\n\n    /**\n     * Optional custom fetch function to use for sending the request.\n     */\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\n\n    /**\n     * Custom headers to send with the requests.\n     */\n    headers?: { [key: string]: string };\n\n    /**\n     * The body of the request (serialized automatically for json requests).\n     */\n    body?: any;\n\n    /**\n     * Query parameters that will be appended to the request url.\n     */\n    query?: { [key: string]: any };\n\n    /**\n     * @deprecated use `query` instead\n     *\n     * for backward-compatibility `params` values are merged with `query`,\n     * but this option may get removed in the final v1 release\n     */\n    params?: { [key: string]: any };\n\n    /**\n     * The request identifier that can be used to cancel pending requests.\n     */\n    requestKey?: string | null;\n\n    /**\n     * @deprecated use `requestKey:string` instead\n     */\n    $cancelKey?: string;\n\n    /**\n     * @deprecated use `requestKey:null` instead\n     */\n    $autoCancel?: boolean;\n}\n\nexport interface CommonOptions extends SendOptions {\n    fields?: string;\n}\n\nexport interface ListOptions extends CommonOptions {\n    page?: number;\n    perPage?: number;\n    sort?: string;\n    filter?: string;\n    skipTotal?: boolean;\n}\n\nexport interface FullListOptions extends ListOptions {\n    batch?: number;\n}\n\nexport interface RecordOptions extends CommonOptions {\n    expand?: string;\n}\n\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\n\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\n\nexport interface RecordSubscribeOptions extends SendOptions {\n    fields?: string;\n    filter?: string;\n    expand?: string;\n}\n\nexport interface LogStatsOptions extends CommonOptions {\n    filter?: string;\n}\n\nexport interface FileOptions extends CommonOptions {\n    thumb?: string;\n    download?: boolean;\n}\n\nexport interface AuthOptions extends CommonOptions {\n    /**\n     * If autoRefreshThreshold is set it will take care to auto refresh\n     * when necessary the auth data before each request to ensure that\n     * the auth state is always valid.\n     *\n     * The value must be in seconds, aka. the amount of seconds\n     * that will be subtracted from the current token `exp` claim in order\n     * to determine whether it is going to expire within the specified time threshold.\n     *\n     * For example, if you want to auto refresh the token if it is\n     * going to expire in the next 30mins (or already has expired),\n     * it can be set to `1800`\n     */\n    autoRefreshThreshold?: number;\n}\n\n// -------------------------------------------------------------------\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    // ---,\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\",\n];\n\n// modifies in place the provided options by moving unknown send options as query parameters.\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\n    if (!options) {\n        return;\n    }\n\n    options.query = options.query || {};\n    for (let key in options) {\n        if (knownSendOptionsKeys.includes(key)) {\n            continue;\n        }\n\n        options.query[key] = options[key];\n        delete options[key];\n    }\n}\n\nexport function serializeQueryParams(params: { [key: string]: any }): string {\n    const result: Array<string> = [];\n\n    for (const key in params) {\n        const encodedKey = encodeURIComponent(key);\n        const arrValue = Array.isArray(params[key]) ? params[key] : [params[key]];\n\n        for (let v of arrValue) {\n            v = prepareQueryParamValue(v);\n            if (v === null) {\n                continue;\n            }\n            result.push(encodedKey + \"=\" + v);\n        }\n    }\n\n    return result.join(\"&\");\n}\n\n// encodes and normalizes the provided query param value.\nfunction prepareQueryParamValue(value: any): null | string {\n    if (value === null || typeof value === \"undefined\") {\n        return null;\n    }\n\n    if (value instanceof Date) {\n        return encodeURIComponent(value.toISOString().replace(\"T\", \" \"));\n    }\n\n    if (typeof value === \"object\") {\n        return encodeURIComponent(JSON.stringify(value));\n    }\n\n    return encodeURIComponent(value);\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/tools/options\";\n\ninterface promiseCallbacks {\n    resolve: Function;\n    reject: Function;\n}\n\ntype Subscriptions = { [key: string]: Array<EventListener> };\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: Subscriptions = {};\n    private lastSentSubscriptions: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * An optional hook that is invoked when the realtime client disconnects\n     * either when unsubscribing from all subscriptions or when the\n     * connection was interrupted or closed by the server.\n     *\n     * The received argument could be used to determine whether the disconnect\n     * is a result from unsubscribing (`activeSubscriptions.length == 0`)\n     * or because of network/server error (`activeSubscriptions.length > 0`).\n     *\n     * If you want to listen for the opposite, aka. when the client connection is established,\n     * subscribe to the `PB_CONNECT` event.\n     */\n    onDisconnect?: (activeSubscriptions: Array<string>) => void;\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: any) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let key = topic;\n\n        // serialize and append the topic options (if any)\n        if (options) {\n            options = Object.assign({}, options); // shallow copy\n            normalizeUnknownQueryParams(options);\n            const serialized =\n                \"options=\" +\n                encodeURIComponent(\n                    JSON.stringify({ query: options.query, headers: options.headers }),\n                );\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = e as MessageEvent;\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[key].length === 1) {\n            // send the updated subscriptions (if it is the first for the key)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(key, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        let needToSubmit = false;\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all listeners related to the topic\n            const subs = this.getSubscriptionsByTopic(topic);\n            for (let key in subs) {\n                if (!this.hasSubscriptionListeners(key)) {\n                    continue; // already unsubscribed\n                }\n\n                for (let listener of this.subscriptions[key]) {\n                    this.eventSource?.removeEventListener(key, listener);\n                }\n                delete this.subscriptions[key];\n\n                // mark for subscriptions change submit if there are no other listeners\n                if (!needToSubmit) {\n                    needToSubmit = true;\n                }\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let key in this.subscriptions) {\n            // \"?\" so that it can be used as end delimiter for the prefix\n            if (!(key + \"?\").startsWith(keyPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            delete this.subscriptions[key];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(\n        topic: string,\n        listener: EventListener,\n    ): Promise<void> {\n        let needToSubmit = false;\n\n        const subs = this.getSubscriptionsByTopic(topic);\n        for (let key in subs) {\n            if (\n                !Array.isArray(this.subscriptions[key]) ||\n                !this.subscriptions[key].length\n            ) {\n                continue; // already unsubscribed\n            }\n\n            let exist = false;\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\n                if (this.subscriptions[key][i] !== listener) {\n                    continue;\n                }\n\n                exist = true; // has at least one matching listener\n                delete this.subscriptions[key][i]; // removes the function reference\n                this.subscriptions[key].splice(i, 1); // reindex the array\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            if (!exist) {\n                continue;\n            }\n\n            // remove the key from the subscriptions list if there are no other listeners\n            if (!this.subscriptions[key].length) {\n                delete this.subscriptions[key];\n            }\n\n            // mark for subscriptions change submit if there are no other listeners\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\n                needToSubmit = true;\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified key\n        if (keyToCheck) {\n            return !!this.subscriptions[keyToCheck]?.length;\n        }\n\n        // check for at least one non-empty subscription\n        for (let key in this.subscriptions) {\n            if (!!this.subscriptions[key]?.length) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\n\n        return this.client\n            .send(\"/api/realtime\", {\n                method: \"POST\",\n                body: {\n                    clientId: this.clientId,\n                    subscriptions: this.lastSentSubscriptions,\n                },\n                requestKey: this.getSubscriptionsCancelKey(),\n            })\n            .catch((err) => {\n                if (err?.isAbort) {\n                    return; // silently ignore aborted pending requests\n                }\n                throw err;\n            });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\n        const result: Subscriptions = {};\n\n        // \"?\" so that it can be used as end delimiter for the topic\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\n\n        for (let key in this.subscriptions) {\n            if ((key + \"?\").startsWith(topic)) {\n                result[key] = this.subscriptions[key];\n            }\n        }\n\n        return result;\n    }\n\n    private getNonEmptySubscriptionKeys(): Array<string> {\n        const result: Array<string> = [];\n\n        for (let key in this.subscriptions) {\n            if (this.subscriptions[key].length) {\n                result.push(key);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.addEventListener(key, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.removeEventListener(key, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0) {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildURL(\"/api/realtime\"));\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(\n                new Error(\"Failed to establish realtime connection.\"),\n            );\n        };\n\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\n            const msgEvent = e as MessageEvent;\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n                .then(async () => {\n                    let retries = 3;\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\n                        retries--;\n                        // resubscribe to ensure that the latest topics are submitted\n                        //\n                        // This is needed because missed topics could happen on reconnect\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                        // was made before the submit was able to complete.\n                        await this.submitSubscriptions();\n                    }\n                })\n                .then(() => {\n                    for (let p of this.pendingConnects) {\n                        p.resolve();\n                    }\n\n                    // reset connect meta\n                    this.pendingConnects = [];\n                    this.reconnectAttempts = 0;\n                    clearTimeout(this.reconnectTimeoutId);\n                    clearTimeout(this.connectTimeoutId);\n\n                    // propagate the PB_CONNECT event\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                    for (let key in connectSubs) {\n                        for (let listener of connectSubs[key]) {\n                            listener(e);\n                        }\n                    }\n                })\n                .catch((err) => {\n                    this.clientId = \"\";\n                    this.connectErrorHandler(err);\n                });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionKeys();\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentSubscriptions.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[\n                this.predefinedReconnectIntervals.length - 1\n            ];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        if (this.clientId && this.onDisconnect) {\n            this.onDisconnect(Object.keys(this.subscriptions));\n        }\n\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/tools/options\";\n\nexport abstract class CrudService<M> extends BaseService {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string;\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\n\n    async getFullList<T = M>(\n        batchOrqueryParams?: number | FullListOptions,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<T>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\n            responseData.items =\n                responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign(\n            {\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        return this.getList<T>(1, 1, options).then((result) => {\n            if (!result?.items?.length) {\n                throw new ClientResponseError({\n                    status: 404,\n                    response: {\n                        code: 404,\n                        message: \"The requested resource wasn't found.\",\n                        data: {},\n                    },\n                });\n            }\n\n            return result.items[0];\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(this.baseCrudPath + \"/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required record id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(\n        batchSize = 500,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign(\n            {\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = list as any as ListResult<T>;\n                const items = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        };\n\n        return request(1);\n    }\n}\n","import { SendOptions } from \"@/tools/options\";\n\nexport function normalizeLegacyOptionsArgs(\n    legacyWarn: string,\n    baseOptions: SendOptions,\n    bodyOrOptions?: any,\n    query?: any,\n): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\n    const hasQuery = typeof query !== \"undefined\";\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n","import Client from \"@/Client\";\nimport { isTokenExpired } from \"@/tools/jwt\";\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n    client: Client,\n    threshold: number,\n    refreshFunc: () => Promise<any>,\n    reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.record;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            ((model?.collectionId || oldModel?.collectionId) &&\n                model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function () {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    };\n}\n","import Client from \"@/Client\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { CrudService } from \"@/services/CrudService\";\nimport { ListResult, RecordModel } from \"@/tools/dtos\";\nimport { normalizeLegacyOptionsArgs } from \"@/tools/legacy\";\nimport {\n    CommonOptions,\n    RecordFullListOptions,\n    RecordListOptions,\n    RecordOptions,\n    SendOptions,\n    RecordSubscribeOptions,\n} from \"@/tools/options\";\nimport { getTokenPayload } from \"@/tools/jwt\";\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/tools/refresh\";\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed PocketBase auth record.\n     */\n    record: T;\n\n    /**\n     * The PocketBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: { [key: string]: any };\n}\n\nexport interface AuthProviderInfo {\n    name: string;\n    displayName: string;\n    state: string;\n    authURL: string;\n    codeVerifier: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n}\n\nexport interface AuthMethodsList {\n    mfa: {\n        enabled: boolean;\n        duration: number;\n    };\n    otp: {\n        enabled: boolean;\n        duration: number;\n    };\n    password: {\n        enabled: boolean;\n        identityFields: Array<string>;\n    };\n    oauth2: {\n        enabled: boolean;\n        providers: Array<AuthProviderInfo>;\n    };\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: { [key: string]: any };\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport interface OTPResponse {\n    otpId: string;\n}\n\nexport class RecordService<M = RecordModel> extends CrudService<M> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + \"/records\";\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    /**\n     * Returns whether the current service collection is superusers.\n     */\n    get isSuperusers(): boolean {\n        return (\n            this.collectionIdOrName == \"_superusers\" ||\n            this.collectionIdOrName == \"_pbc_2773867675\"\n        );\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = M>(\n        topic: string,\n        callback: (data: RecordSubscription<T>) => void,\n        options?: RecordSubscribeOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"Missing topic.\");\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        return this.client.realtime.subscribe(\n            this.collectionIdOrName + \"/\" + topic,\n            callback,\n            options,\n        );\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe from the specified topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(\n                this.collectionIdOrName + \"/\" + topic,\n            );\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batch?: number,\n        options?: RecordListOptions,\n    ): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batchOrOptions?: number | RecordFullListOptions,\n        options?: RecordListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: RecordListOptions,\n    ): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFirstListItem<T = M>(\n        filter: string,\n        options?: RecordListOptions,\n    ): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the updated id, then\n     * on success the `client.authStore.record` will be updated with the new response record fields.\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.record?.id === item?.id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                let authExpand = Object.assign({}, this.client.authStore.record.expand);\n                let authRecord = Object.assign({}, this.client.authStore.record, item);\n                if (authExpand) {\n                    // for now \"merge\" only top-level expand\n                    authRecord.expand = Object.assign(authExpand, item.expand);\n                }\n\n                this.client.authStore.save(this.client.authStore.token, authRecord);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.record?.id === id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record as any);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            record: record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n                // @todo remove after deleting the pre v0.23 API response fields\n                fields: \"mfa,otp,password,oauth2\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/auth-methods\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    identity: usernameOrEmail,\n                    password: password,\n                },\n            },\n            options,\n        );\n\n        // note: consider to deprecate\n        let autoRefreshThreshold;\n        if (this.isSuperusers) {\n            autoRefreshThreshold = options.autoRefreshThreshold;\n            delete options.autoRefreshThreshold;\n            if (!options.autoRefresh) {\n                resetAutoRefresh(this.client);\n            }\n        }\n\n        let authData = await this.client.send(\n            this.baseCollectionPath + \"/auth-with-password\",\n            options,\n        );\n\n        authData = this.authResponse<T>(authData);\n\n        if (autoRefreshThreshold && this.isSuperusers) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({ autoRefresh: true }),\n                () =>\n                    this.authWithPassword<T>(\n                        usernameOrEmail,\n                        password,\n                        Object.assign({ autoRefresh: true }, options),\n                    ),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createdData, options?).\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                provider: provider,\n                code: code,\n                codeVerifier: codeVerifier,\n                redirectURL: redirectURL,\n                createData: createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyParams?: { [key: string]: any },\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * Note1: When creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     *\n     * Note2: Safari may block the default `urlCallback` popup because\n     * it doesn't allow `window.open` calls as part of an `async` click functions.\n     * To workaround this you can either change your click handler to not be marked as `async`\n     * OR manually call `window.open` before your `async` function and use the\n     * window reference in your own custom `urlCallback` (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061).\n     * For example:\n     * ```js\n     * <button id=\"btn\">Login with Gitlab</button>\n     * ...\n     * document.getElementById(\"btn\").addEventListener(\"click\", () => {\n     *     pb.collection(\"users\").authWithOAuth2({\n     *         provider: \"gitlab\",\n     *     }).then((authData) => {\n     *         console.log(authData)\n     *     }).catch((err) => {\n     *         console.log(err, err.originalError);\n     *     });\n     * })\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2<T = M>(\n        options: OAuth2AuthConfig,\n    ): Promise<RecordAuthResponse<T>>;\n\n    authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\n            console.warn(\n                \"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\",\n            );\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || \"\",\n                args?.[1] || \"\",\n                args?.[2] || \"\",\n                args?.[3] || \"\",\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before any async calls due to Safari restrictions\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window | null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        const requestKeyOptions: SendOptions = {};\n        const requestKey = config.requestKey;\n        if (requestKey) {\n            requestKeyOptions.requestKey = requestKey;\n        }\n\n        return this.listAuthMethods(requestKeyOptions)\n            .then((authMethods) => {\n                const provider = authMethods.oauth2.providers.find(\n                    (p) => p.name === config.provider,\n                );\n                if (!provider) {\n                    throw new ClientResponseError(\n                        new Error(`Missing or invalid provider \"${config.provider}\".`),\n                    );\n                }\n\n                const redirectURL = this.client.buildURL(\"/api/oauth2-redirect\");\n\n                // find the AbortController associated with the current request key (if any)\n                const cancelController = requestKey\n                    ? this.client[\"cancelControllers\"]?.[requestKey]\n                    : undefined;\n                if (cancelController) {\n                    cancelController.signal.onabort = () => {\n                        cleanup();\n                    };\n                }\n\n                return new Promise(async (resolve, reject) => {\n                    try {\n                        await realtime.subscribe(\"@oauth2\", async (e) => {\n                            const oldState = realtime.clientId;\n\n                            try {\n                                if (!e.state || oldState !== e.state) {\n                                    throw new Error(\"State parameters don't match.\");\n                                }\n\n                                if (e.error || !e.code) {\n                                    throw new Error(\n                                        \"OAuth2 redirect error or missing code: \" +\n                                            e.error,\n                                    );\n                                }\n\n                                // clear the non SendOptions props\n                                const options = Object.assign({}, config);\n                                delete options.provider;\n                                delete options.scopes;\n                                delete options.createData;\n                                delete options.urlCallback;\n\n                                // reset the cancelController listener as it will be triggered by the next api call\n                                if (cancelController?.signal?.onabort) {\n                                    cancelController.signal.onabort = null;\n                                }\n\n                                const authData = await this.authWithOAuth2Code<T>(\n                                    provider.name,\n                                    e.code,\n                                    provider.codeVerifier,\n                                    redirectURL,\n                                    config.createData,\n                                    options,\n                                );\n\n                                resolve(authData);\n                            } catch (err) {\n                                reject(new ClientResponseError(err));\n                            }\n\n                            cleanup();\n                        });\n\n                        const replacements: { [key: string]: any } = {\n                            state: realtime.clientId,\n                        };\n                        if (config.scopes?.length) {\n                            replacements[\"scope\"] = config.scopes.join(\" \");\n                        }\n\n                        const url = this._replaceQueryParams(\n                            provider.authURL + redirectURL,\n                            replacements,\n                        );\n\n                        let urlCallback =\n                            config.urlCallback ||\n                            function (url: string) {\n                                if (eagerDefaultPopup) {\n                                    eagerDefaultPopup.location.href = url;\n                                } else {\n                                    // it could have been blocked due to its empty initial url,\n                                    // try again...\n                                    eagerDefaultPopup = openBrowserPopup(url);\n                                }\n                            };\n\n                        await urlCallback(url);\n                    } catch (err) {\n                        cleanup();\n                        reject(new ClientResponseError(err));\n                    }\n                });\n            })\n            .catch((err) => {\n                cleanup();\n                throw err; // rethrow\n            }) as Promise<RecordAuthResponse<T>>;\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\n\n    async authRefresh<T = M>(\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: passwordResetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestVerification(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-verification\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore.record.verified` will be updated to `true`.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmVerification(\n        verificationToken: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    async confirmVerification(\n        verificationToken: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmVerification(\n        verificationToken: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: verificationToken,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\n            .then(() => {\n                // on success manually update the current auth record verified state\n                const payload = getTokenPayload(verificationToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    !model.verified &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    model.verified = true;\n                    this.client.authStore.save(this.client.authStore.token, model);\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestEmailChange(\n        newEmail: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                newEmail: newEmail,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore` will be cleared.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: emailChangeToken,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\n            .then(() => {\n                const payload = getTokenPayload(emailChangeToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    this.client.authStore.clear();\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Lists all linked external auth providers for the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listExternalAuths(\n        recordId: string,\n        options?: CommonOptions,\n    ): Promise<Array<RecordModel>> {\n        return this.client.collection(\"_externalAuths\").getFullList(\n            Object.assign({}, options, {\n                filter: this.client.filter(\"recordRef = {:id}\", { id: recordId }),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Unlink a single external auth provider from the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        const ea = await this.client.collection(\"_externalAuths\").getFirstListItem(\n            this.client.filter(\"recordRef = {:recordId} && provider = {:provider}\", {\n                recordId,\n                provider,\n            }),\n        );\n\n        return this.client\n            .collection(\"_externalAuths\")\n            .delete(ea.id, options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record OTP to the provided email.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestOTP(email: string, options?: CommonOptions): Promise<OTPResponse> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { email: email },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/request-otp\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via OTP.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOTP<T = M>(\n        otpId: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { otpId, password },\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-otp\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Impersonate authenticates with the specified recordId and\n     * returns a new client with the received auth token in a memory store.\n     *\n     * If `duration` is 0 the generated auth token will fallback\n     * to the default collection auth token duration.\n     *\n     * This action currently requires superusers privileges.\n     *\n     * @throws {ClientResponseError}\n     */\n    async impersonate(\n        recordId: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<Client> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { duration: duration },\n            },\n            options,\n        );\n        options.headers = options.headers || {};\n        if (!options.headers.Authorization) {\n            options.headers.Authorization = this.client.authStore.token;\n        }\n\n        // create a new client loaded with the impersonated auth state\n        // ---\n        const client = new Client(\n            this.client.baseURL,\n            new BaseAuthStore(),\n            this.client.lang,\n        );\n\n        const authData = await client.send(\n            this.baseCollectionPath + \"/impersonate/\" + encodeURIComponent(recordId),\n            options,\n        );\n\n        client.authStore.save(authData?.token, this.decode(authData?.record || {}));\n        // ---\n\n        return client;\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(\n        url: string,\n        replacements: { [key: string]: any } = {},\n    ): string {\n        let urlPath = url;\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: { [key: string]: string } = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue;\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query +=\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\n                \"=\" +\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\n        }\n\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window | null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(\n            new Error(\n                `Not in a browser context - please pass a custom urlCallback function.`,\n            ),\n        );\n    }\n\n    let width = 1024;\n    let height = 768;\n\n    let windowWidth = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = windowWidth / 2 - width / 2;\n    let top = windowHeight / 2 - height / 2;\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        \"popup_window\",\n        \"width=\" +\n            width +\n            \",height=\" +\n            height +\n            \",top=\" +\n            top +\n            \",left=\" +\n            left +\n            \",resizable,menubar=no\",\n    );\n}\n","import { CrudService } from \"@/services/CrudService\";\nimport { CollectionModel } from \"@/tools/dtos\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/collections\";\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and their fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     *\n     * @throws {ClientResponseError}\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body: {\n                    collections: collections,\n                    deleteMissing: deleteMissing,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\n    }\n\n    /**\n     * Returns type indexed map with scaffolded collection models\n     * populated with their default field values.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getScaffolds(\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: CollectionModel }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/meta/scaffolds\", options);\n    }\n\n    /**\n     * Deletes all records associated with the specified collection.\n     *\n     * @throws {ClientResponseError}\n     */\n    async truncate(collectionIdOrName: string, options?: CommonOptions): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\n                this.baseCrudPath +\n                    \"/\" +\n                    encodeURIComponent(collectionIdOrName) +\n                    \"/truncate\",\n                options,\n            )\n            .then(() => true);\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { ListResult, LogModel } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/tools/options\";\n\nexport interface HourlyStats {\n    total: number;\n    date: string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logs list.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<LogModel>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(\"/api/logs\", options);\n    }\n\n    /**\n     * Returns a single log by its id.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(\"/api/logs/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required log id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns logs statistics.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/stats\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface HealthCheckResponse {\n    code: number;\n    message: string;\n    data: { [key: string]: any };\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     *\n     * @throws {ClientResponseError}\n     */\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/health\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions, FileOptions } from \"@/tools/options\";\n\nexport class FileService extends BaseService {\n    /**\n     * @deprecated Please replace with `pb.files.getURL()`.\n     */\n    getUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.files.getUrl() with pb.files.getURL()\");\n        return this.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getURL(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return \"\";\n        }\n\n        const parts = [];\n        parts.push(\"api\");\n        parts.push(\"files\");\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\n        parts.push(encodeURIComponent(record.id));\n        parts.push(encodeURIComponent(filename));\n\n        let result = this.client.buildURL(parts.join(\"/\"));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete queryParams.download;\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result;\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\"/api/files/token\", options)\n            .then((data) => data?.token || \"\");\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface BackupFileInfo {\n    key: string;\n    size: number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options);\n    }\n\n    /**\n     * Initializes a new backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    name: basename,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options).then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async upload(\n        bodyParams: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * @deprecated Please use `getDownloadURL()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        console.warn(\n            \"Please replace pb.backups.getDownloadUrl() with pb.backups.getDownloadURL()\",\n        );\n        return this.getDownloadURL(token, key);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using a\n     * superuser file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadURL(token: string, key: string): string {\n        return this.client.buildURL(\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\n        );\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface CronJob {\n    id: string;\n    expression: string;\n}\n\nexport class CronService extends BaseService {\n    /**\n     * Returns list with all registered cron jobs.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<CronJob>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/crons\", options);\n    }\n\n    /**\n     * Runs the specified cron job.\n     *\n     * @throws {ClientResponseError}\n     */\n    async run(jobId: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/crons/${encodeURIComponent(jobId)}`, options)\n            .then(() => true);\n    }\n}\n","/**\n * Checks if the specified value is a file (aka. File, Blob, RN file object).\n */\nexport function isFile(val: any): boolean {\n    return (\n        (typeof Blob !== \"undefined\" && val instanceof Blob) ||\n        (typeof File !== \"undefined\" && val instanceof File) ||\n        // check for React Native file object format\n        // (see https://github.com/pocketbase/pocketbase/discussions/2002#discussioncomment-5254168)\n        (val !== null &&\n            typeof val === \"object\" &&\n            val.uri &&\n            ((typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n                (typeof global !== \"undefined\" && (global as any).HermesInternal)))\n    );\n}\n\n/**\n * Loosely checks if the specified body is a FormData instance.\n */\nexport function isFormData(body: any): boolean {\n    return (\n        body &&\n        // we are checking the constructor name because FormData\n        // is not available natively in some environments and the\n        // polyfill(s) may not be globally accessible\n        (body.constructor.name === \"FormData\" ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== \"undefined\" && body instanceof FormData))\n    );\n}\n\n/**\n * Checks if the submitted body object has at least one Blob/File field value.\n */\nexport function hasFileField(body: { [key: string]: any }): boolean {\n    for (const key in body) {\n        const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n        for (const v of values) {\n            if (isFile(v)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Converts analyzes the provided body and converts it to FormData\n * in case a plain object with File/Blob values is used.\n */\nexport function convertToFormDataIfNeeded(body: any): any {\n    if (\n        typeof FormData === \"undefined\" ||\n        typeof body === \"undefined\" ||\n        typeof body !== \"object\" ||\n        body === null ||\n        isFormData(body) ||\n        !hasFileField(body)\n    ) {\n        return body;\n    }\n\n    const form = new FormData();\n\n    for (const key in body) {\n        const val = body[key];\n\n        // skip undefined values for consistency with JSON.stringify\n        // (see https://github.com/pocketbase/pocketbase/issues/6731#issuecomment-2812382827)\n        if (typeof val === \"undefined\") {\n            continue;\n        }\n\n        if (typeof val === \"object\" && !hasFileField({ data: val })) {\n            // send json-like values as jsonPayload to avoid the implicit string value normalization\n            let payload: { [key: string]: any } = {};\n            payload[key] = val;\n            form.append(\"@jsonPayload\", JSON.stringify(payload));\n        } else {\n            // in case of mixed string and file/blob\n            const normalizedVal = Array.isArray(val) ? val : [val];\n            for (let v of normalizedVal) {\n                form.append(key, v);\n            }\n        }\n    }\n\n    return form;\n}\n\n/**\n * Converts the provided FormData instance into a plain object.\n *\n * For consistency with the server multipart/form-data inferring,\n * the following normalization rules are applied for plain multipart string values:\n *   - \"true\" is converted to the json \"true\"\n *   - \"false\" is converted to the json \"false\"\n *   - numeric strings are converted to json number ONLY if the resulted\n *     minimal number string representation is the same as the provided raw string\n *     (aka. scientific notations, \"Infinity\", \"0.0\", \"0001\", etc. are kept as string)\n *   - any other string (empty string too) is left as it is\n */\nexport function convertFormDataToObject(formData: FormData): { [key: string]: any } {\n    let result: { [key: string]: any } = {};\n\n    formData.forEach((v, k) => {\n        if (k === \"@jsonPayload\" && typeof v == \"string\") {\n            try {\n                let parsed = JSON.parse(v);\n                Object.assign(result, parsed);\n            } catch (err) {\n                console.warn(\"@jsonPayload error:\", err);\n            }\n        } else {\n            if (typeof result[k] !== \"undefined\") {\n                if (!Array.isArray(result[k])) {\n                    result[k] = [result[k]];\n                }\n                result[k].push(inferFormDataValue(v));\n            } else {\n                result[k] = inferFormDataValue(v);\n            }\n        }\n    });\n\n    return result;\n}\n\nconst inferNumberCharsRegex = /^[\\-\\.\\d]+$/;\n\nfunction inferFormDataValue(value: any): any {\n    if (typeof value != \"string\") {\n        return value;\n    }\n\n    if (value == \"true\") {\n        return true;\n    }\n\n    if (value == \"false\") {\n        return false;\n    }\n\n    // note: expects the provided raw string to match exactly with the minimal string representation of the parsed number\n    if (\n        (value[0] === \"-\" || (value[0] >= \"0\" && value[0] <= \"9\")) &&\n        inferNumberCharsRegex.test(value)\n    ) {\n        let num = +value;\n        if (\"\" + num === value) {\n            return num;\n        }\n    }\n\n    return value;\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { isFile, isFormData, convertFormDataToObject } from \"@/tools/formdata\";\nimport {\n    SendOptions,\n    RecordOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\n\nexport interface BatchRequest {\n    method: string;\n    url: string;\n    json?: { [key: string]: any };\n    files?: { [key: string]: Array<any> };\n    headers?: { [key: string]: string };\n}\n\nexport interface BatchRequestResult {\n    status: number;\n    body: any;\n}\n\nexport class BatchService extends BaseService {\n    private requests: Array<BatchRequest> = [];\n    private subs: { [key: string]: SubBatchService } = {};\n\n    /**\n     * Starts constructing a batch request entry for the specified collection.\n     */\n    collection(collectionIdOrName: string): SubBatchService {\n        if (!this.subs[collectionIdOrName]) {\n            this.subs[collectionIdOrName] = new SubBatchService(\n                this.requests,\n                collectionIdOrName,\n            );\n        }\n\n        return this.subs[collectionIdOrName];\n    }\n\n    /**\n     * Sends the batch requests.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send(options?: SendOptions): Promise<Array<BatchRequestResult>> {\n        const formData = new FormData();\n\n        const jsonData = [];\n\n        for (let i = 0; i < this.requests.length; i++) {\n            const req = this.requests[i];\n\n            jsonData.push({\n                method: req.method,\n                url: req.url,\n                headers: req.headers,\n                body: req.json,\n            });\n\n            if (req.files) {\n                for (let key in req.files) {\n                    const files = req.files[key] || [];\n                    for (let file of files) {\n                        formData.append(\"requests.\" + i + \".\" + key, file);\n                    }\n                }\n            }\n        }\n\n        formData.append(\"@jsonPayload\", JSON.stringify({ requests: jsonData }));\n\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: formData,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/batch\", options);\n    }\n}\n\nexport class SubBatchService {\n    private requests: Array<BatchRequest> = [];\n    private readonly collectionIdOrName: string;\n\n    constructor(requests: Array<BatchRequest>, collectionIdOrName: string) {\n        this.requests = requests;\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * Registers a record upsert request into the current batch queue.\n     *\n     * The request will be executed as update if `bodyParams` have a valid existing record `id` value, otherwise - create.\n     */\n    upsert(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PUT\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record create request into the current batch queue.\n     */\n    create(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"POST\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record update request into the current batch queue.\n     */\n    update(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PATCH\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record delete request into the current batch queue.\n     */\n    delete(id: string, options?: SendOptions): void {\n        options = Object.assign({}, options);\n\n        const request: BatchRequest = {\n            method: \"DELETE\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    private prepareRequest(request: BatchRequest, options: SendOptions) {\n        normalizeUnknownQueryParams(options);\n\n        request.headers = options.headers;\n        request.json = {};\n        request.files = {};\n\n        // serialize query parameters\n        // -----------------------------------------------------------\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                request.url += (request.url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n        }\n\n        // extract json and files body data\n        // -----------------------------------------------------------\n        let body = options.body;\n        if (isFormData(body)) {\n            body = convertFormDataToObject(body);\n        }\n\n        for (const key in body) {\n            const val = body[key];\n\n            if (isFile(val)) {\n                request.files[key] = request.files[key] || [];\n                request.files[key].push(val);\n            } else if (Array.isArray(val)) {\n                const foundFiles = [];\n                const foundRegular = [];\n                for (const v of val) {\n                    if (isFile(v)) {\n                        foundFiles.push(v);\n                    } else {\n                        foundRegular.push(v);\n                    }\n                }\n\n                if (foundFiles.length > 0 && foundFiles.length == val.length) {\n                    // only files\n                    // ---\n                    request.files[key] = request.files[key] || [];\n                    for (let file of foundFiles) {\n                        request.files[key].push(file);\n                    }\n                } else {\n                    // empty or mixed array (both regular and File/Blob values)\n                    // ---\n                    request.json[key] = foundRegular;\n\n                    if (foundFiles.length > 0) {\n                        // add \"+\" to append if not already since otherwise\n                        // the existing regular files will be deleted\n                        // (the mixed values order is preserved only within their corresponding groups)\n                        let fileKey = key;\n                        if (!key.startsWith(\"+\") && !key.endsWith(\"+\")) {\n                            fileKey += \"+\";\n                        }\n\n                        request.files[fileKey] = request.files[fileKey] || [];\n                        for (let file of foundFiles) {\n                            request.files[fileKey].push(file);\n                        }\n                    }\n                }\n            } else {\n                request.json[key] = val;\n            }\n        }\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\nimport { SettingsService } from \"@/services/SettingsService\";\nimport { RecordService } from \"@/services/RecordService\";\nimport { CollectionService } from \"@/services/CollectionService\";\nimport { LogService } from \"@/services/LogService\";\nimport { RealtimeService } from \"@/services/RealtimeService\";\nimport { HealthService } from \"@/services/HealthService\";\nimport { FileService } from \"@/services/FileService\";\nimport { BackupService } from \"@/services/BackupService\";\nimport { CronService } from \"@/services/CronService\";\nimport { BatchService } from \"@/services/BatchService\";\nimport { RecordModel } from \"@/tools/dtos\";\nimport {\n    SendOptions,\n    FileOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\nimport { isFormData, convertToFormDataIfNeeded } from \"@/tools/formdata\";\n\nexport interface BeforeSendResult {\n    [key: string]: any; // for backward compatibility\n    url?: string;\n    options?: { [key: string]: any };\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseURL: string;\n\n    /**\n     * Legacy getter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    get baseUrl(): string {\n        return this.baseURL;\n    }\n\n    /**\n     * Legacy setter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    set baseUrl(v: string) {\n        this.baseURL = v;\n    }\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * const pb = new PocketBase(\"https://example.com\")\n     *\n     * pb.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     })\n     *\n     *     return { url, options }\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    beforeSend?: (\n        url: string,\n        options: SendOptions,\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * const pb = new PocketBase(\"https://example.com\")\n     *\n     * pb.afterSend = function (response, data, options) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             response: { ... },\n     *         })\n     *     }\n     *\n     *     return data;\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    afterSend?: ((response: Response, data: any) => any) &\n        ((response: Response, data: any, options: SendOptions) => any);\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    /**\n     * An instance of the service that handles the **Cron APIs**.\n     */\n    readonly crons: CronService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(baseURL = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n        this.baseURL = baseURL;\n        this.lang = lang;\n\n        if (authStore) {\n            this.authStore = authStore;\n        } else if (typeof window != \"undefined\" && !!(window as any).Deno) {\n            // note: to avoid common security issues we fallback to runtime/memory store in case the code is running in Deno env\n            this.authStore = new BaseAuthStore();\n        } else {\n            this.authStore = new LocalAuthStore();\n        }\n\n        // common services\n        this.collections = new CollectionService(this);\n        this.files = new FileService(this);\n        this.logs = new LogService(this);\n        this.settings = new SettingsService(this);\n        this.realtime = new RealtimeService(this);\n        this.health = new HealthService(this);\n        this.backups = new BackupService(this);\n        this.crons = new CronService(this);\n    }\n\n    /**\n     * @deprecated\n     * With PocketBase v0.23.0 admins are converted to a regular auth\n     * collection named \"_superusers\", aka. you can use directly collection(\"_superusers\").\n     */\n    get admins(): RecordService {\n        return this.collection(\"_superusers\");\n    }\n\n    /**\n     * Creates a new batch handler for sending multiple transactional\n     * create/update/upsert/delete collection requests in one network call.\n     *\n     * Example:\n     * ```js\n     * const batch = pb.createBatch();\n     *\n     * batch.collection(\"example1\").create({ ... })\n     * batch.collection(\"example2\").update(\"RECORD_ID\", { ... })\n     * batch.collection(\"example3\").delete(\"RECORD_ID\")\n     * batch.collection(\"example4\").upsert({ ... })\n     *\n     * await batch.send()\n     * ```\n     */\n    createBatch(): BatchService {\n        return new BatchService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     */\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Constructs a filter expression with placeholders populated from a parameters object.\n     *\n     * Placeholder parameters are defined with the `{:paramName}` notation.\n     *\n     * The following parameter values are supported:\n     *\n     * - `string` (_single quotes are autoescaped_)\n     * - `number`\n     * - `boolean`\n     * - `Date` object (_stringified into the PocketBase datetime format_)\n     * - `null`\n     * - everything else is converted to a string using `JSON.stringify()`\n     *\n     * Example:\n     *\n     * ```js\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\n     *    'title ~ {:title} && created >= {:created}',\n     *    { title: \"example\", created: new Date()}\n     * ))\n     * ```\n     */\n    filter(raw: string, params?: { [key: string]: any }): string {\n        if (!params) {\n            return raw;\n        }\n\n        for (let key in params) {\n            let val = params[key];\n            switch (typeof val) {\n                case \"boolean\":\n                case \"number\":\n                    val = \"\" + val;\n                    break;\n                case \"string\":\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    if (val === null) {\n                        val = \"null\";\n                    } else if (val instanceof Date) {\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\n                    } else {\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\n                    }\n            }\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\n        }\n\n        return raw;\n    }\n\n    /**\n     * @deprecated Please use `pb.files.getURL()`.\n     */\n    getFileUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.getFileUrl() with pb.files.getURL()\");\n        return this.files.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * @deprecated Please use `pb.buildURL()`.\n     */\n    buildUrl(path: string): string {\n        console.warn(\"Please replace pb.buildUrl() with pb.buildURL()\");\n        return this.buildURL(path);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildURL(path: string): string {\n        let url = this.baseURL;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== \"undefined\" &&\n            !!window.location &&\n            !url.startsWith(\"https://\") &&\n            !url.startsWith(\"http://\")\n        ) {\n            url = window.location.origin?.endsWith(\"/\")\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\n                : window.location.origin || \"\";\n\n            if (!this.baseURL.startsWith(\"/\")) {\n                url += window.location.pathname || \"/\";\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\n            }\n\n            url += this.baseURL;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildURL(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (\n                typeof result.url !== \"undefined\" ||\n                typeof result.options !== \"undefined\"\n            ) {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn &&\n                    console.warn(\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\n                    );\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\n            options.body &&\n            typeof options.body !== \"string\"\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data: any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data, options);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url: response.url,\n                        status: response.status,\n                        data: data,\n                    });\n                }\n\n                return data as T;\n            })\n            .catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\n\n        // auto convert the body to FormData, if needed\n        options.body = convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        normalizeUnknownQueryParams(options);\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === \"undefined\") {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, \"Content-Type\") === null &&\n            !isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Content-Type\": \"application/json\",\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Accept-Language\": this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            this.getHeader(options.headers, \"Authorization\") === null\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                Authorization: this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(\n        headers: { [key: string]: string } | undefined,\n        name: string,\n    ): string | null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new PocketBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc;\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc;\n\n        // An *optional* initial data to load into the store.\n        initial?: string | Promise<any>;\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._enqueue(() => this._loadInitial(config.initial));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord): void {\n        super.save(token, record);\n\n        let value = \"\";\n        try {\n            value = JSON.stringify({ token, record });\n        } catch (err) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n    /**\n     * Initializes the auth store state.\n     */\n    private async _loadInitial(payload?: string | Promise<any>) {\n        try {\n            payload = await payload;\n\n            if (payload) {\n                let parsed;\n                if (typeof payload === \"string\") {\n                    parsed = JSON.parse(payload) || {};\n                } else if (typeof payload === \"object\") {\n                    parsed = payload;\n                }\n\n                this.save(parsed.token || \"\", parsed.record || parsed.model || null);\n            }\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}